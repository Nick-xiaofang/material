{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","children":[{"parent":"270b57d67f7f","children":[{"parent":"a0143120bab6","children":[{"parent":"680d7c99de1d","children":[],"id":"a46b6a52be8a","title":"描述客观事物的数值、字符，能输入到计算机并且被计算机处理的各种符号的集合<br>"},{"parent":"680d7c99de1d","children":[],"id":"c5abca2de1f2","title":"数据就是信息在计算机中的表示"}],"id":"680d7c99de1d","title":"数据<br>"},{"parent":"a0143120bab6","children":[{"parent":"7b23b3ebcb36","children":[],"id":"627038770cc9","title":"数据元素就是数据的基本单位<br>"},{"parent":"7b23b3ebcb36","children":[],"id":"a5a50d468637","title":"在计算机程序中，通常把数据元素作为一个整体进行处理<br>"},{"parent":"7b23b3ebcb36","children":[],"id":"06ca41831044","title":"例如：<br>描述学生信息的一条数据记录就是一个数据元素<br>描述一个点坐标的信息就是一个数据元素<br>数据元素通常由若干个数据项组成<br>"},{"parent":"7b23b3ebcb36","children":[],"id":"4cdfff9002f1","title":"例如：<br>描述学生信息中的姓名、学号、成绩都是数据项<br>点坐标中的横坐标、纵坐标就是数据项"}],"id":"7b23b3ebcb36","title":"数据元素"},{"parent":"a0143120bab6","children":[{"parent":"067bb5347b39","children":[],"id":"048c14502e0b","title":"一组相同性质的数据元素的集合<br>"},{"parent":"067bb5347b39","children":[],"id":"da23cfd4d957","title":"例如：<br>     学校中所有学生的集合就是数据对象<br>     平面坐标系中所有的点的集合就是数据项"}],"id":"067bb5347b39","title":"数据对象"},{"parent":"a0143120bab6","children":[{"parent":"57686ada2454","children":[],"id":"ed1fefe47074","title":"相互之间存在的一种或多种特定关系的数据元素的集合"},{"parent":"57686ada2454","children":[],"id":"2f9af82f57ad","title":"数据结构就是数据元素之间的关系"},{"parent":"57686ada2454","children":[],"id":"45e8b8c96bd9","title":"数据结构分为逻辑结构和物理结构"},{"parent":"57686ada2454","children":[{"parent":"ec891b77d2e1","children":[],"id":"b8020f2379e4","title":"集合：数据仅仅属于同一个集合，他们之间没有其他的相互关系"},{"parent":"ec891b77d2e1","children":[],"id":"ca12fc7950e3","title":"线性：描述一对一的关系"},{"parent":"ec891b77d2e1","children":[],"id":"3a2e61792a50","title":"树形：描述一对多的关系"},{"parent":"ec891b77d2e1","children":[],"id":"43eab534b73c","title":"图形：描述多对多的关系"}],"collapsed":false,"id":"ec891b77d2e1","title":"数据的逻辑结构有四种"},{"parent":"57686ada2454","children":[{"parent":"4b7d76d1f709","children":[],"id":"13ab008be2bf","title":"数据结构=(D,S)"},{"parent":"4b7d76d1f709","children":[],"id":"6c6f050f2ead","title":"D：数据元素的集合"},{"parent":"4b7d76d1f709","children":[],"id":"874bf7298d08","title":"S：D中元素之间的关系的集合"},{"parent":"4b7d76d1f709","children":[{"parent":"f90fba9853ea","children":[],"id":"78c50a701f2e","title":"<span style=\"font-size: inherit;\">二元组：set = (D,S)<br></span>D = {01,02,03,04,05,06}<br>S&nbsp; = {}"},{"parent":"f90fba9853ea","children":[],"id":"d5d8753eb212","title":"在set集合中，数据元素除了属于同一个集合外，不存在其他的关系，这就是集合的结构"},{"parent":"f90fba9853ea","image":{"w":198,"h":123,"url":"http://cdn.processon.com/5fd846ab07912906da569b84?e=1608012988&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:uYAuejjV9kyoys_JlCsZV1qsF4A="},"children":[],"id":"9c83aebbb2f7","title":"图解<br>"}],"id":"f90fba9853ea","title":"例1：集合"},{"parent":"4b7d76d1f709","children":[{"parent":"33ac5492688a","children":[],"id":"b399aceb3541","title":"二元组：linearity = (D,S)<br>             D = {01,02,03,04,05,06}<br>             S  = {&lt;01,04&gt;,&lt;04,06&gt;,&lt;06,02&gt;,&lt;02,05&gt;,&lt;05,03&gt;}"},{"parent":"33ac5492688a","children":[],"id":"1fa2dae685b4","title":"在数据结构linearity中，数据元素是有序的，有一个被称为“第一个”的数据元素（01）<br>还有一个被称为“最后一个”的元素（03），除了第一个元素外，其他每个元素都有一个直接前驱元素<br>除了最后一个元素外，其他每个元素都有一个直接后继的元素<br>"},{"parent":"33ac5492688a","children":[],"id":"904a51ff4da5","title":"数据元素之间是一对一的关系"},{"parent":"33ac5492688a","image":{"w":329,"h":116,"url":"http://cdn.processon.com/5fd847c41e085306e0f95f53?e=1608013268&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0wuqsIuIVciK5bP0CQhq_msa3p8="},"children":[],"id":"0d66ed2eecb3","title":"图解"}],"id":"33ac5492688a","title":"例2：线形"},{"parent":"4b7d76d1f709","children":[{"parent":"4db6a619c91e","children":[],"id":"fedc4f5b9d27","title":"二元组：tree = (D,S)<br>D = {01,02,03,04,05,06}<br>S = {&lt;01,02&gt;,&lt;01,03&gt;,&lt;02,04&gt;,&lt;02,05&gt;,&lt;03,06&gt;}<br>"},{"parent":"4db6a619c91e","children":[],"id":"c0d4260c0a7d","title":"在tree数据结构中，除了第一个元素（01）外，每个元素都有且只有一个直接前驱元素，每个元素可以有多个直接后继元素"},{"parent":"4db6a619c91e","children":[],"id":"566074b0cebd","title":"数据元素之间是一对多的关系"},{"image":{"w":286,"h":175,"url":"http://cdn.processon.com/5fd848c41e085306e0f962f6?e=1608013524&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Mp7Bmi-fF4W3TPljg3h6-AFOCUQ="},"parent":"4db6a619c91e","children":[],"id":"b0b639a244c5","title":"图解<br>"}],"id":"4db6a619c91e","title":"例3：树形"},{"parent":"4b7d76d1f709","children":[{"parent":"5bc7087b8461","children":[],"id":"43d84010be4c","title":"二元组：graph = (D,S)<br>D = {01,02,03,04,05,06}<br>S = {&lt;01,02&gt;,&lt;01,03&gt;,&lt;02,05&gt;,&lt;05,06&gt;,&lt;06,02&gt;,&lt;05,04&gt;,&lt;04,05&gt;}"},{"parent":"5bc7087b8461","children":[],"id":"8f0aff6d54a4","title":"在graph数据结构中，每个元素可以有多个直接前驱元素，每个元素也可以有多个直接后继元素"},{"parent":"5bc7087b8461","children":[],"id":"19f116a941fe","title":"数据元素之间是多对多的关系"},{"parent":"5bc7087b8461","image":{"w":339,"h":178,"url":"http://cdn.processon.com/5fd84942e401fd06ddc51b36?e=1608013650&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:wLzz-ZKaKU1pD4JBIgb9deGPSHQ="},"children":[],"id":"2836d618bfd0","title":"图解"}],"id":"5bc7087b8461","title":"例4：图形"}],"collapsed":true,"id":"4b7d76d1f709","title":"数据的逻辑结构一般采用二元组的形式定义"},{"parent":"57686ada2454","children":[{"parent":"136fe36e2433","children":[],"id":"a211c614f4ff","title":"数据的物理结构就是逻辑结构在计算机中的存储表示"},{"parent":"136fe36e2433","children":[{"parent":"d5df3a4e8bde","children":[],"id":"ac82ffc15d2b","title":"顺序存储<br>"},{"parent":"d5df3a4e8bde","children":[],"id":"bc7e94ba68ea","title":"链式存储"}],"collapsed":true,"id":"d5df3a4e8bde","title":"两种存储表示形式<br>"},{"parent":"136fe36e2433","children":[{"parent":"d027ddae2cdd","children":[],"id":"535f7edfe15f","title":"顺序存储就是使用一块连续的存储空间，数据之间紧挨在一起<br>数据的前驱和后继的关系可以通过数据元素在内存中相对位置反映出来"},{"image":{"w":189,"h":25,"url":"http://cdn.processon.com/5fd84b0a07912906da56ab37?e=1608014106&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:grfSv6dID9ak7VBOUJHASFPcb9w="},"parent":"d027ddae2cdd","children":[],"id":"bc2c5f20b1d2","title":"图解<br>"}],"collapsed":true,"id":"d027ddae2cdd","title":"顺序存储"},{"parent":"136fe36e2433","children":[{"parent":"01ba6aba09b5","children":[],"id":"016ee55d3cfe","title":"数据元素的存储位置不是连续的，每个元素中都会保存下一个元素的存储位置"},{"parent":"01ba6aba09b5","image":{"w":207,"h":74,"url":"http://cdn.processon.com/5fd84ba0e0b34d06f4f75adb?e=1608014256&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ms7nmD7cNVKPjEHtzV5qdJWQG9w="},"children":[],"id":"b273e0db0046","title":"图解"}],"collapsed":false,"id":"01ba6aba09b5","title":"链式存储"}],"collapsed":true,"id":"136fe36e2433","title":"数据的物理结构"}],"id":"57686ada2454","title":"数据结构"}],"collapsed":true,"id":"a0143120bab6","title":"1.基本概念<br>"},{"parent":"270b57d67f7f","children":[{"parent":"f4bb9bf81647","children":[],"id":"e8aca3641eaa","title":"abstract data type 简称：ADT"},{"parent":"f4bb9bf81647","children":[],"id":"c16fb868c58e","title":"由一组数据模型及该模型上的一组操作组成"},{"parent":"f4bb9bf81647","children":[],"id":"31226dcca498","title":"抽象数据类型一半使用一个三元组表示：<br>ADT =（D，S，P）<br>D：数据对象<br>S：D上的关系<br>P：D上的操作"},{"parent":"f4bb9bf81647","children":[],"id":"b84a933e30aa","title":"在定义抽象数据类型时，可以使用以下的格式：<br>ADT 抽象数据类型名{<br>&nbsp; &nbsp; &nbsp;数据对象：&lt;数据对象的定义&gt;<br>&nbsp; &nbsp; &nbsp;数据关系：&lt;数据关系的定义&gt;<br>&nbsp; &nbsp; &nbsp;数据操作：&lt;基本操作的定义&gt;<br>}"},{"parent":"f4bb9bf81647","children":[],"id":"1c2531706b37","title":"抽象数据类型可以对应一个Java类，数据对象与数据关系可以通过类的成员变量来存储和表示，数据操作可以使用方法来实现<br>"}],"collapsed":true,"id":"f4bb9bf81647","title":"2.抽象数据类型"},{"parent":"270b57d67f7f","children":[{"parent":"458330585163","children":[{"parent":"121f6def0b5d","children":[],"id":"9e255833ac26","title":"linearity = (D,R)<br>D = {a1,a2,a3,a4}<br>R = {&lt;a1,a2&gt;,&lt;a2,a3&gt;,&lt;a3,a4&gt;}<br>a1元素称为第一个元素，其他的元素都有一个直接前驱;<br>a4元素称为最后一个元素，其他的元素都有一个直接后继&nbsp;"},{"parent":"121f6def0b5d","children":[],"id":"1529963b343b","title":"生活中的线性结构：排队"}],"collapsed":false,"id":"121f6def0b5d","title":"基本概念"},{"parent":"458330585163","children":[{"parent":"8bef9fe3e4c8","children":[],"id":"f2f908aee2df","title":"ADT List{<br>&nbsp; &nbsp; &nbsp; &nbsp;数据对象：D = {ai 属于某个数据类型，i = 0,1,2,3...}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D = {a0,a1,a2,a3,a4 ... an},所有的元素都是同一个数据类型<br>&nbsp; &nbsp; &nbsp; &nbsp;数据关系：R = {&lt;ai,a(i+1)&gt;}<br>&nbsp; &nbsp; &nbsp; &nbsp;数据操作：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getSize()：返回线性表中元素的个数<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isEmpty()：判断线性表是否为空，线性表为空返回true，否则返回false<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert(i,e)：在线性表的i索引值位置插入元素e，如果索引值i越界，则报错<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contains(e)：在线性表中判断是否存在元素e，存在返回true<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOf(e)：返回元素e在线性表中的索引值，如果不存在元素e，则返回-1<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove(e)：删除线性表中第一个与e相同的元素，删除成功返回删除的元素，元素不存在返回null<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remove(i)：删除线性表中指定索引值位置的元素，返回删除的元素，如果索引值i越界，则报错<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replace(i,e)：把线性表中索引值为i的元素替换为元素e，如果索引值i越界，则报错<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get(i)：返回线性表中索引值为i的元素，如果索引值i越界，则报错<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertBefore(p,e)：在线性表中元素p的前面插入元素e<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertAfter(p,e)：在线性表中元素p的后面插入元素e<br>}"},{"parent":"8bef9fe3e4c8","children":[],"id":"aabab16e8e5a","title":"注：凡是涉及到索引的方法，都要先判断索引是否越界"},{"parent":"8bef9fe3e4c8","children":[],"id":"82f37951135a","title":"一般来说抽象数据类型都会抽象成一个接口"}],"collapsed":true,"id":"8bef9fe3e4c8","title":"线性表的抽象数据类型"},{"parent":"458330585163","children":[{"parent":"020503d54469","children":[],"id":"68a65408ef1c","title":"使用Java中的接口来表示ADT中的数据操作，在使用类完成抽象数据类型时，<br>只要这个类实现接口即可完成抽象数据类型中定义的操作"},{"parent":"020503d54469","children":[],"id":"6c880227b553","title":"package pers.chenjiahao.linearity.operator;<br><br>/**<br> * 通过接口定义一组线性表中的操作<br> */<br>public interface MyList {<br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;int getSize(); // 返回线性表中的元素的个数</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;boolean isEmpty(); // 判断线性表是否为空</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;void insert(int i, Object e); // 在线性表的i索引值添加元素e</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;boolean contains(Object e); // 判断线性表中是否包含元素e</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;int indexOf(Object e); // 返回线性表中元素e的索引值</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;Object remove(Object e); // 删除线性表中第一个与e相同的元素，并返回该元素</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;Object remove(int i); // 删除线性表中索引值为i的元素，并返回该元素</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;Object replace(int i, Object e); // 使用元素e替换线性表中i位置的元素，并返回旧的元素</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;Object get(int i); // 返回索引值为i的元素</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;boolean insertBefore(Object p, Object e); // 在线性表元素p的前面插入元素e</span><br><span style=\"font-size: inherit;\">&nbsp; &nbsp; &nbsp; &nbsp;boolean insertAfter(Object p, Object e); // 在线性表元素p的后面插入元素e</span><br>}<br>"}],"collapsed":true,"id":"020503d54469","title":"MyList接口"},{"parent":"458330585163","children":[{"parent":"64eb797748ef","children":[{"parent":"8342e76dd26b","children":[],"id":"55d251844351","title":"线性表的顺序存储就是使用一组地址连续的存储空间来依次存储线性表中的元素<br>以数据元素在计算机内存的地址相邻性来表示数据元素之间的关系<br>在Java中可以使用数组来存储线性表中的数据元素，数组就是一块连续的存储空间"}],"collapsed":false,"id":"8342e76dd26b","title":"基本概念"},{"parent":"64eb797748ef","children":[{"parent":"ff86b1b7af67","children":[{"image":{"w":606,"h":256,"url":"http://cdn.processon.com/5fdc4baee0b34d66b81a940a?e=1608276415&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:bp7iLzXaDNu-aFUkXoxxFtqFNGM="},"parent":"202450f46e37","children":[],"id":"8d129112930c","title":"图解<br>"}],"collapsed":false,"id":"202450f46e37","title":"插入元素"},{"parent":"ff86b1b7af67","children":[{"parent":"18f2081c9a25","image":{"w":608,"h":236,"url":"http://cdn.processon.com/5fdc4c166376891bdc6d9066?e=1608276519&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:GJ9QeP8k7576_rvWFBUI7toU8T4="},"children":[],"id":"d0d24007a517","title":"图解"}],"collapsed":false,"id":"18f2081c9a25","title":"删除元素"}],"collapsed":false,"id":"ff86b1b7af67","title":"原理"},{"parent":"64eb797748ef","children":[{"parent":"aba459634c12","children":[],"id":"aaa33727a50e","title":"创建一个MyArrayList类，实现MyList接口"},{"parent":"aba459634c12","children":[{"parent":"e305e66c6c61","children":[],"id":"2451f0ccee9b","title":"package pers.chenjiahao.linearity.queuestorageimpl;<br><br>import pers.chenjiahao.linearity.operator.MyList;<br><br>/**<br> * 实现MyList接口<br> */<br>public class MyArrayList implements MyList {<br>    // 定义数组来保存数据元素<br>    private Object[] elements;<br>    // 数组的默认初始化容量<br>    private static final int DEFAULT_CAPACITY = 16;<br>    // 保存数据元素的个数<br>    private int size;<br><br>    // 在创建的时候默认会给数组赋予一个初始化容量<br>    public MyArrayList() {<br>        elements = new Object[DEFAULT_CAPACITY];<br>    }<br><br>    // 自定义初始化容量<br>    public MyArrayList(int initialCapacity) {<br>        elements = new Object[initialCapacity];<br>    }<br><br>    // 返回元素的个数<br>    @Override<br>    public int getSize() {<br>        return size;<br>    }<br><br>    // 判断线性表是否为空<br>    @Override<br>    public boolean isEmpty() {<br>        return size == 0;<br>    }<br><br>    // 在线表的i位置插入元素e<br>    @Override<br>    public void insert(int i, Object e) {<br>        // 判断索引值i是否越界<br>        if (i &lt; 0 || i &gt; size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        // 如果数组已满，对数组进行扩容<br>        if (size &gt;= elements.length){<br>            // 数组扩容<br>            expandSpace();<br>        }<br>        // 从i开始，把元素依次后移<br>        for (int j = size; j &gt; i; j--) {<br>            elements[j] = elements[j-1];<br>        }<br>        // 把元素e存储到i位置<br>        elements[i] = e;<br>        // 元素的个数增加1<br>        size++;<br>    }<br><br>    /**<br>     * 数组扩容<br>     */<br>    private void expandSpace() {<br>        // 定义一个更大的数组,默认按2倍大小扩容<br>        Object[] newElements = new Object[elements.length * 2];<br>        // 把原来数组的内容复制到新的数组中<br>        for (int i = 0; i &lt; elements.length; i++) {<br>            newElements[i] = elements[i];<br>        }<br>        // 让原来的数组名指向新的数组<br>        elements = newElements;<br>    }<br><br>    // 判断当前线性表中是否包含元素e<br>    @Override<br>    public boolean contains(Object e) {<br>        return indexOf(e) &gt;= 0;<br>    }<br><br>    // 返回元素e在线性表中第一次出现位置的索引值，如果不存在返回-1<br>    @Override<br>    public int indexOf(Object e) {<br>        // 判断e是否为空<br>        if (e == null){<br>            // 如果线性表中，用户可能添加了null<br>            for (int i = 0; i &lt; size; i++) {<br>                if (elements[i] == null){<br>                    return i;<br>                }<br>            }<br>        }else {<br>            // 遍历数组<br>            for (int i = 0; i &lt; size; i++) {<br>                if (e.equals(elements[i])){<br>                    return i;<br>                }<br>            }<br>        }<br>        // 能走到这里说明元素不存在<br>        return -1;<br>    }<br><br>    // 在线性表中删除第一个与e相同的元素<br>    @Override<br>    public Object remove(Object e) {<br>        // 获取e在线性表中的索引值<br>        int index = indexOf(e);<br>        if (index &lt; 0){<br>            // 线性表中不存在元素e<br>            return null;<br>        }<br>        return remove(index);<br>    }<br><br>    // 在线性表中删除指定索引值的元素<br>    @Override<br>    public Object remove(int i) {<br>        // 判断i是否越界<br>        if (i &lt; 0 || i &gt;= size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        // 把要删除的元素保存起来<br>        Object old = elements[i];<br>        // 把i+1开始的元素，依次前移<br>        for (int j = i; j &lt; size - 1; j++) {<br>            elements[j] = elements[j + 1];<br>        }<br>        // 把最后的元素放置为null<br>        elements[size - 1] = null;<br>        // 修改元素的个数<br>        size--;<br>        return old;<br>    }<br><br>    // 把索引值为i的元素替换为e<br>    @Override<br>    public Object replace(int i, Object e) {<br>        // 判断是否越界<br>        if (i &lt; 0 || i &gt;= size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        // 保存原来的值<br>        Object old = elements[i];<br>        // 替换<br>        elements[i] = e;<br>        // 把原来的元素值返回<br>        return old;<br>    }<br><br>    // 返回指定位置的元素<br>    @Override<br>    public Object get(int i) {<br>        // 判断是否越界<br>        if (i &lt; 0 || i &gt;= size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        return elements[i];<br>    }<br><br>    // 在指定的元素前插入元素<br>    @Override<br>    public boolean insertBefore(Object p, Object e) {<br>        // 先确定元素p在线性表中的位置<br>        int index = indexOf(p);<br>        if (index &lt; 0){<br>            // p元素不存在，插入不成功<br>            return false;<br>        }<br>        // 插入元素<br>        insert(index,e);<br>        return true;<br>    }<br><br>    // 在指定的元素后插入元素<br>    @Override<br>    public boolean insertAfter(Object p, Object e) {<br>        // 先确定元素p在线性表中的位置<br>        int index = indexOf(p);<br>        if (index &lt; 0){<br>            // p元素不存在，插入不成功<br>            return false;<br>        }<br>        // 插入元素<br>        insert(index + 1,e);<br>        return true;<br>    }<br><br>    // 重写toString方法<br>    @Override<br>    public String toString() {<br>        // 把线性表中每个元素连接起来，便利数组中已添加的元素<br>        StringBuilder sb = new StringBuilder();<br>        sb.append(\"[\");<br>        for (int i = 0; i &lt; size; i++) {<br>            sb.append(elements[i]);<br>            if (i &lt; size - 1){<br>                sb.append(\",\");<br>            }<br>        }<br>        sb.append(\"]\");<br>        return sb.toString();<br>    }<br>}<br>"}],"collapsed":true,"id":"e305e66c6c61","title":"完整代码"},{"parent":"aba459634c12","children":[{"parent":"ddaaac4999d9","children":[{"parent":"423ce6b1ba51","children":[],"id":"8a8b6f6e8fc1","title":"// 返回元素的个数<br>    @Override<br>    public int getSize() {<br>        return size;<br>    }"}],"collapsed":true,"id":"423ce6b1ba51","title":"1.getSize()<br>"},{"parent":"ddaaac4999d9","children":[{"parent":"bdbef8e72f14","children":[],"id":"d76381ff4255","title":"// 判断线性表是否为空<br>@Override<br>    public boolean isEmpty() {<br>        return size == 0;<br>    }"}],"collapsed":true,"id":"bdbef8e72f14","title":"2.isEmpty()<br>"},{"parent":"ddaaac4999d9","children":[{"parent":"e8f3eb46dc9b","children":[],"id":"efd67b7d3872","title":"// 在线表的i位置插入元素e<br>    @Override<br>    public void insert(int i, Object e) {<br>        // 判断索引值i是否越界<br>        if (i &lt; 0 || i &gt; size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        // 如果数组已满，对数组进行扩容<br>        if (size &gt;= elements.length){<br>            // 数组扩容<br>            expandSpace();<br>        }<br>        // 从i开始，把元素依次后移<br>        for (int j = size; j &gt; i; j--) {<br>            elements[j] = elements[j-1];<br>        }<br>        // 把元素e存储到i位置<br>        elements[i] = e;<br>        // 元素的个数增加1<br>        size++;<br>    }"}],"collapsed":true,"id":"e8f3eb46dc9b","title":"3.insert(int i, Object e)<br>"},{"parent":"ddaaac4999d9","children":[{"parent":"2b0891abaf95","children":[],"id":"2e5dc06f5f5e","title":"// 判断当前线性表中是否包含元素e<br>    @Override<br>    public boolean contains(Object e) {<br>        return indexOf(e) &gt;= 0;<br>    }"}],"collapsed":true,"id":"2b0891abaf95","title":"4.contains(Object e)"},{"parent":"ddaaac4999d9","children":[{"parent":"29a098ad1761","children":[],"id":"a0df0541293e","title":"// 返回元素e在线性表中第一次出现位置的索引值，如果不存在返回-1<br>    @Override<br>    public int indexOf(Object e) {<br>        // 判断e是否为空<br>        if (e == null){<br>            // 如果线性表中，用户可能添加了null<br>            for (int i = 0; i &lt; size; i++) {<br>                if (elements[i] == null){<br>                    return i;<br>                }<br>            }<br>        }else {<br>            // 遍历数组<br>            for (int i = 0; i &lt; size; i++) {<br>                if (e.equals(elements[i])){<br>                    return i;<br>                }<br>            }<br>        }<br>        // 能走到这里说明元素不存在<br>        return -1;<br>    }"}],"collapsed":true,"id":"29a098ad1761","title":"5.indexOf(Object e)"},{"parent":"ddaaac4999d9","children":[{"parent":"443ce4ccfba4","children":[],"id":"cae58ca62fa2","title":"// 在线性表中删除第一个与e相同的元素<br>    @Override<br>    public Object remove(Object e) {<br>        // 获取e在线性表中的索引值<br>        int index = indexOf(e);<br>        if (index &lt; 0){<br>            // 线性表中不存在元素e<br>            return null;<br>        }<br>        return remove(index);<br>    }"}],"collapsed":true,"id":"443ce4ccfba4","title":"6.remove(Object e)<br>"},{"parent":"ddaaac4999d9","children":[{"parent":"df77ad7801a6","children":[],"id":"91110efa9f63","title":"// 在线性表中删除指定索引值的元素<br>    @Override<br>    public Object remove(int i) {<br>        // 判断i是否越界<br>        if (i &lt; 0 || i &gt;= size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        // 把要删除的元素保存起来<br>        Object old = elements[i];<br>        // 把i+1开始的元素，依次前移<br>        for (int j = i; j &lt; size - 1; j++) {<br>            elements[j] = elements[j + 1];<br>        }<br>        // 把最后的元素放置为null<br>        elements[size - 1] = null;<br>        // 修改元素的个数<br>        size--;<br>        return old;<br>    }"}],"collapsed":true,"id":"df77ad7801a6","title":"7.remove(int i)"},{"parent":"ddaaac4999d9","children":[{"parent":"184d9d3ea0d1","children":[],"id":"39160bbdc6ad","title":"// 把索引值为i的元素替换为e<br>    @Override<br>    public Object replace(int i, Object e) {<br>        // 判断是否越界<br>        if (i &lt; 0 || i &gt;= size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        // 保存原来的值<br>        Object old = elements[i];<br>        // 替换<br>        elements[i] = e;<br>        // 把原来的元素值返回<br>        return old;<br>    }"}],"collapsed":true,"id":"184d9d3ea0d1","title":"8.replace(int i, Object e)"},{"parent":"ddaaac4999d9","children":[{"parent":"e8786c867583","children":[],"id":"1512a5e0d6be","title":"// 返回指定位置的元素<br>    @Override<br>    public Object get(int i) {<br>        // 判断是否越界<br>        if (i &lt; 0 || i &gt;= size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        return elements[i];<br>    }"}],"collapsed":true,"id":"e8786c867583","title":"9.get(int i)<br>"},{"parent":"ddaaac4999d9","children":[{"parent":"2ab6bcbcce9c","children":[],"id":"40bfc4d1708c","title":"// 在指定的元素前插入元素<br>    @Override<br>    public boolean insertBefore(Object p, Object e) {<br>        // 先确定元素p在线性表中的位置<br>        int index = indexOf(p);<br>        if (index &lt; 0){<br>            // p元素不存在，插入不成功<br>            return false;<br>        }<br>        // 插入元素<br>        insert(index,e);<br>        return true;<br>    }"}],"collapsed":true,"id":"2ab6bcbcce9c","title":"10.insertBefore(Object p, Object e)"},{"parent":"ddaaac4999d9","children":[{"parent":"94acec6b8a96","children":[],"id":"90c11a8dc18d","title":"// 在指定的元素后插入元素<br>    @Override<br>    public boolean insertAfter(Object p, Object e) {<br>        // 先确定元素p在线性表中的位置<br>        int index = indexOf(p);<br>        if (index &lt; 0){<br>            // p元素不存在，插入不成功<br>            return false;<br>        }<br>        // 插入元素<br>        insert(index + 1,e);<br>        return true;<br>    }<br>"}],"collapsed":true,"id":"94acec6b8a96","title":"11.insertAfter(Object p, Object e)"},{"parent":"ddaaac4999d9","children":[{"parent":"b014d745e918","children":[],"id":"21dbb6078f80","title":"// 重写toString方法<br>    @Override<br>    public String toString() {<br>        // 把线性表中每个元素连接起来，便利数组中已添加的元素<br>        StringBuilder sb = new StringBuilder();<br>        sb.append(\"[\");<br>        for (int i = 0; i &lt; size; i++) {<br>            sb.append(elements[i]);<br>            if (i &lt; size - 1){<br>                sb.append(\",\");<br>            }<br>        }<br>        sb.append(\"]\");<br>        return sb.toString();<br>    }"}],"collapsed":true,"id":"b014d745e918","title":"12.toString()<br>"},{"parent":"ddaaac4999d9","children":[{"parent":"c18b5e4f0f85","children":[],"id":"aeea43425169","title":"// 数组扩容<br>    private void expandSpace() {<br>        // 定义一个更大的数组,默认按2倍大小扩容<br>        Object[] newElements = new Object[elements.length * 2];<br>        // 把原来数组的内容复制到新的数组中<br>        for (int i = 0; i &lt; elements.length; i++) {<br>            newElements[i] = elements[i];<br>        }<br>        // 让原来的数组名指向新的数组<br>        elements = newElements;<br>    }"}],"collapsed":true,"id":"c18b5e4f0f85","title":"13.private void expandSpace()<br>"}],"collapsed":true,"id":"ddaaac4999d9","title":"各个功能模块代码"},{"parent":"aba459634c12","children":[{"parent":"4a7b40fc5516","children":[],"id":"07fa2b539056","title":"package pers.chenjiahao.linearity.queuestorageimpl.test;<br><br>import pers.chenjiahao.linearity.operator.MyList;<br>import pers.chenjiahao.linearity.queuestorageimpl.MyArrayList;<br><br>/**<br> * 测试MyArrayList<br> */<br>public class MyArrayListTest {<br>    public static void main(String[] args) {<br>        // 创建MyArrayList对象<br>        MyList list1 = new MyArrayList();<br>        // 判断是否为空<br>        System.out.println(list1.isEmpty()); // true<br>        // 获取长度<br>        System.out.println(list1.getSize()); // 0<br>        // 添加元素<br>        list1.insert(0,\"aa\");<br>        list1.insert(1,\"bb\");<br>        list1.insert(0,\"cc\");<br>        System.out.println(list1.isEmpty()); // false<br>        System.out.println(list1.getSize()); // 3<br>        // 把线性表中的内容打印输出<br>        System.out.println(list1); // [cc,aa,bb]<br>        // 元素的索引值<br>        System.out.println(list1.indexOf(\"cc\")); // 0<br>        System.out.println(list1.indexOf(\"bb\")); // 2<br>        System.out.println(list1.indexOf(\"dd\")); // -1<br>        // 判断是否存在<br>        System.out.println(list1.contains(\"aa\")); // true<br>        System.out.println(list1.contains(\"xx\")); // false<br>        // 删除<br>        list1.remove(\"dd\");  // 删除不存在的元素，没有影响<br>        System.out.println(list1); // [cc,aa,bb]<br>        list1.remove(\"bb\");<br>        System.out.println(list1); // [cc,aa]<br>        list1.remove(0);<br>        System.out.println(list1);// [aa]<br>        // 重新插入点数据<br>        list1.insert(0,\"xx\");<br>        list1.insert(0,\"oo\");<br>        list1.insert(0,\"yy\");<br>        System.out.println(list1); // [yy,oo,xx,aa]<br>        // 替换<br>        list1.replace(0,\"YY\");<br>        System.out.println(list1); // [YY,oo,xx,aa]<br>        // 返回值指定索引的元素<br>        System.out.println(list1.get(0)); // YY<br>        System.out.println(list1.get(1)); // oo<br>        System.out.println(list1.get(3)); // aa<br>        // System.out.println(list1.get(4)); // 4越界<br>        // 在指定元素的前面/后面插入元素<br>        list1.insertBefore(\"oo\",\"JJ\");<br>        System.out.println(list1); // [YY,JJ,oo,xx,aa]<br>        list1.insertAfter(\"oo\",\"jj\");<br>        System.out.println(list1); // [YY,JJ,oo,jj,xx,aa]<br>        list1.insertAfter(\"TT\",\"BB\");<br>        System.out.println(list1); // [YY,JJ,oo,jj,xx,aa]<br>    }<br>}<br>"}],"collapsed":true,"id":"4a7b40fc5516","title":"测试类"}],"collapsed":false,"id":"aba459634c12","title":"代码实现"},{"parent":"64eb797748ef","children":[{"parent":"1717dccbace2","children":[{"parent":"8c584d89d89b","children":[],"id":"1717733d105b","title":"顺序存储是使用数组实现的，数组可以通过索引值快速访问每个元素<br>"},{"image":{"w":584,"h":260,"url":"http://cdn.processon.com/5fdc4faa1e085304fb7f36bf?e=1608277434&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TC_pTMRByAd4n4iYM5-5ztw-J8I="},"parent":"8c584d89d89b","children":[],"id":"02cd1dbf43a2","title":"图解"}],"collapsed":false,"id":"8c584d89d89b","title":"优点<br>"},{"parent":"1717dccbace2","children":[{"parent":"c2c602ea42b1","children":[],"id":"b2c62c319ece","title":"在插入/删除元素时，需要移动大量的元素"},{"parent":"c2c602ea42b1","children":[],"id":"0349c4a562ef","title":"当线性表长度变化较大时，很难确定存储空间的容量"}],"collapsed":false,"id":"c2c602ea42b1","title":"缺点"}],"collapsed":false,"id":"1717dccbace2","title":"特点<br>"},{"parent":"64eb797748ef","children":[{"parent":"691193933965","children":[],"id":"f1d8d30b8b56","title":"适用于元素的插入/删除操作较少，主要是查询操作"}],"collapsed":false,"id":"691193933965","title":"应用场景"}],"collapsed":false,"id":"64eb797748ef","title":"线性表的顺序存储"},{"parent":"458330585163","children":[{"parent":"07a1363cbe04","children":[{"parent":"400087c20a55","children":[{"parent":"91b2a1d9dca1","children":[],"id":"c9b2e65cf362","title":"单向链表，也叫单链表"},{"parent":"91b2a1d9dca1","children":[],"id":"5dc40a3fc8b0","title":"每个存储单元至少有两个域，一个用来存储数据，一个用来保存下个存储单元的引用"},{"parent":"91b2a1d9dca1","image":{"w":603,"h":136,"url":"http://cdn.processon.com/5fdc50e66376891bdc6da9f5?e=1608277750&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:4uaRBOxlEFI46Yqd1gzRkYmxozg="},"children":[],"id":"9f21e7b40f3d","title":"图解"}],"collapsed":false,"id":"91b2a1d9dca1","title":"基本概念"},{"parent":"400087c20a55","children":[{"parent":"26b4ecf26663","children":[{"parent":"dd859c2c781b","children":[],"id":"e2056acf355f","title":"不需要移动元素"},{"image":{"w":579,"h":215,"url":"http://cdn.processon.com/5fdc512ae0b34d66b81ab08e?e=1608277818&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:LQtuGFT_X-vlvTNaH35lcaq-5PI="},"parent":"dd859c2c781b","children":[],"id":"5e96da9ec68e","title":"图解"}],"id":"dd859c2c781b","title":"插入和删除元素"}],"collapsed":false,"id":"26b4ecf26663","title":"原理"},{"parent":"400087c20a55","children":[{"parent":"ad3c087bfdc2","children":[],"id":"2ab0456f4e5b","title":"创建一个MySingleLink类，实现MyList接口"},{"parent":"ad3c087bfdc2","children":[{"parent":"b63e6713b916","children":[],"id":"b9516bbc8782","title":"package pers.chenjiahao.linearity.singlelinkimpl;<br><br>import pers.chenjiahao.linearity.operator.MyList;<br><br>public class MySingleLink implements MyList {<br>    // 表示头节点<br>    private Node head;<br>    // 保存元素的个数<br>    private int size;<br><br>    // 返回元素的个数<br>    @Override<br>    public int getSize() {<br>        return size;<br>    }<br><br>    // 判断线性表是否为空<br>    @Override<br>    public boolean isEmpty() {<br>        return size == 0;<br>    }<br><br>    // 在线性表中插入元素<br>    @Override<br>    public void insert(int i, Object e) {<br>        // 判断索引值是否越界<br>        if (i &lt; 0 || i &gt; size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        // 创建结点<br>        Node newNode = new Node(e,null);<br>        // 头节点为null的情况，线性表还没被创建,刚添加的结点就是头结点<br>        if (head == null){<br>            head = newNode;<br>        }else {<br>            // 在0位置插入结点<br>            if (i == 0){<br>                // 修改新节点的next 域，指向原来的头节点<br>                newNode.next = head;<br>                // 刚插入的节点就是新的头节点<br>                head = newNode;<br>            }else {<br>                // 在其余的位置插入结点,先找到i-1这个结点<br>                Node pNode = head;<br>                for (int j = 1; j &lt; i; j++) {<br>                   pNode = pNode.next;<br>                }<br>                // 给新结点的next先赋值 i 结点 也就是pNode的next<br>                newNode.next = pNode.next;<br>                // 改变i-1位置结点的next，让pNode的next结点指向newNode<br>                pNode.next = newNode;<br>            }<br>        }<br>        // 元素个数+1<br>        size++;<br>    }<br><br>    // 判断线性表中是否包含指定的元素<br>    @Override<br>    public boolean contains(Object e) {<br>        return indexOf(e) &gt;= 0;<br>    }<br><br>    // 返回元素e在线性表中第一次出现的索引值<br>    @Override<br>    public int indexOf(Object e) {<br>        // 保存元素e的索引值<br>        int index = 0;<br>        Node pNode = head;<br>        while (pNode != null){<br>            if (e == null &amp;&amp; pNode.data == null){<br>                return index;<br>            }else if (e != null &amp;&amp; e.equals(pNode.data)){<br>                return index;<br>            }<br>            index++;<br>            pNode = pNode.next;<br>        }<br>        return -1;<br>    }<br><br>    // 从线性表中删除第一个与e相同的元素<br>    @Override<br>    public Object remove(Object e) {<br>        // 找到元素e第一次出现的位置<br>        int index = indexOf(e);<br>        if (index &lt; 0){<br>            // 元素不存在<br>            return null;<br>        }<br>        return remove(index);<br>    }<br><br>    // 从线性表中删除指定索引的元素<br>    @Override<br>    public Object remove(int i) {<br>        // 判断是否越界<br>        if (i &lt; 0 || i &gt;= size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>        Node pNode = head;<br>        // 删除头结点(i为0时候)<br>        if (i == 0){<br>            head = head.next;<br>            size--;<br>            return pNode.data; // 返回删除头结点的数据<br>        }<br>        // 删除的是中间的元素，找到i-1结点<br>        for (int j = 1; j &lt; i; j++) {<br>            pNode = pNode.next;<br>        }<br>        // 保存删除结点的数据<br>        Object old = pNode.next.data;<br>        // 将i - 1 结点的next指针与改变一下(让i-1的next指向i+1结点，相当于删除了i)<br>        pNode.next = pNode.next.next;<br>        size--;<br>        return old;<br>    }<br><br>    // 把线性表中i索引值位置的元素替换为e<br>    @Override<br>    public Object replace(int i, Object e) {<br>        // 判断是否越界<br>        checkIndex(i);<br>        // 找到i结点<br>        Node pNode = getNode(i);<br>        // 保存一下旧的数据<br>        Object old = pNode.data;<br>        // 替换<br>        pNode.data = e;<br>        return old;<br>    }<br><br>    // 返回线性表中i索引值的元素<br>    @Override<br>    public Object get(int i) {<br>        // 判断是否越界<br>        Node pNode = getNode(i);<br>        return pNode.data;<br>    }<br><br>    // 定义一个方法来检查索引值是否越界<br>    private void checkIndex(int i){<br>        if (i &lt; 0 || i &gt;= size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>    }<br><br>    // 定义一个方法返回i索引值的元素<br>    private Node getNode(int i){<br>        if (i &lt; 0 || i&gt;= size){<br>            return null;<br>        }<br>        if (i == 0){<br>            return head;<br>        }<br>        // 找到i结点<br>        Node pNode = head;<br>        for (int j = 0; j &lt; i; j++) {<br>            pNode = pNode.next;<br>        }<br>        return pNode;<br>    }<br>    // 在指定的元素p的前面插入元素e<br>    @Override<br>    public boolean insertBefore(Object p, Object e) {<br>        // 找p的索引位置<br>        int index = indexOf(p);<br>        if (index &lt; 0){<br>            // 元素p不存在<br>            return false;<br>        }<br>        insert(index,e);<br>        return true;<br>    }<br><br>    @Override<br>    public boolean insertAfter(Object p, Object e) {<br>        // 找p的索引位置<br>        int index = indexOf(p);<br>        if (index &lt; 0){<br>            // 元素p不存在<br>            return false;<br>        }<br>        insert(index + 1,e);<br>        return true;<br>    }<br><br>    // 重写toString()方法<br>    @Override<br>    public String toString() {<br>        // 把链表中各个结点的数据与连接起来<br>        StringBuilder sb = new StringBuilder();<br>        sb.append(\"[\");<br>        Node pNode = head;<br>        while (pNode != null){<br>            sb.append(pNode.data);<br>            // 使用逗号分割<br>            if (pNode.next != null){<br>                sb.append(\",\");<br>            }<br>            // 指针向后移动<br>            pNode = pNode.next;<br>        }<br>        sb.append(\"]\");<br>        return sb.toString();<br>    }<br><br>    // 定义一个内部类表示单向链表中的结点<br>    private class Node{<br>        // 保存数据<br>        Object data;<br>        // 保存下一个结点的引用<br>        Node next;<br>        // 构造<br>        public Node(Object data, Node next) {<br>            this.data = data;<br>            this.next = next;<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"b63e6713b916","title":"完整代码"},{"parent":"ad3c087bfdc2","children":[{"parent":"a0987c4df8fe","children":[{"parent":"d41bac256b20","children":[],"id":"8ab744a3bed0","title":"// 返回元素的个数<br>    @Override<br>    public int getSize() {<br>        return size;<br>    }"}],"collapsed":true,"id":"d41bac256b20","title":"1.getSize()<br>"},{"parent":"a0987c4df8fe","children":[{"parent":"03979e002ee0","children":[],"id":"bfbfa2896749","title":"// 判断线性表是否为空<br>    @Override<br>    public boolean isEmpty() {<br>        return size == 0;<br>    }"}],"collapsed":true,"id":"03979e002ee0","title":"2.isEmpty()<br>"},{"parent":"a0987c4df8fe","children":[{"parent":"88300dbb8d96","children":[],"id":"28826befa279","title":"// 在线性表中插入元素\n    @Override\n    public void insert(int i, Object e) {\n        // 判断索引值是否越界\n        if (i &lt; 0 || i &gt; size){\n            throw new IndexOutOfBoundsException(i + \"越界\");\n        }\n        // 创建结点\n        Node newNode = new Node(e,null);\n        // 头节点为null的情况，线性表还没被创建,刚添加的结点就是头结点\n        if (head == null){\n            head = newNode;\n        }else {\n            // 在0位置插入结点\n            if (i == 0){\n                // 修改新节点的next 域，指向原来的头节点\n                newNode.next = head;\n                // 刚插入的节点就是新的头节点\n                head = newNode;\n            }else {\n                // 在其余的位置插入结点,先找到i-1这个结点\n                Node pNode = head;\n                for (int j = 1; j &lt; i; j++) {\n                   pNode = pNode.next;\n                }\n                // 给新结点的next先赋值 i 结点 也就是pNode的next\n                newNode.next = pNode.next;\n                // 改变i-1位置结点的next，让pNode的next结点指向newNode\n                pNode.next = newNode;\n            }\n        }\n        // 元素个数+1\n        size++;\n    }"}],"collapsed":true,"id":"88300dbb8d96","title":"3.insert(int i, Object e)<br>"},{"parent":"a0987c4df8fe","children":[{"parent":"7ab2641f3d32","children":[],"id":"67eb11e1b449","title":"// 判断线性表中是否包含指定的元素<br>    @Override<br>    public boolean contains(Object e) {<br>        return indexOf(e) &gt;= 0;<br>    }"}],"collapsed":true,"id":"7ab2641f3d32","title":"4.contains(Object e)"},{"parent":"a0987c4df8fe","children":[{"parent":"5e40bbf11c12","children":[],"id":"97fd7f831dd2","title":"// 返回元素e在线性表中第一次出现的索引值\n    @Override\n    public int indexOf(Object e) {\n        // 保存元素e的索引值\n        int index = 0;\n        Node pNode = head;\n        while (pNode != null){\n            if (e == null && pNode.data == null){\n                return index;\n            }else if (e != null && e.equals(pNode.data)){\n                return index;\n            }\n            index++;\n            pNode = pNode.next;\n        }\n        return -1;\n    }"}],"collapsed":true,"id":"5e40bbf11c12","title":"5.indexOf(Object e)"},{"parent":"a0987c4df8fe","children":[{"parent":"c7084419aa07","children":[],"id":"2d983dc51f27","title":"// 从线性表中删除第一个与e相同的元素<br>    @Override<br>    public Object remove(Object e) {<br>        // 找到元素e第一次出现的位置<br>        int index = indexOf(e);<br>        if (index &lt; 0){<br>            // 元素不存在<br>            return null;<br>        }<br>        return remove(index);<br>    }"}],"collapsed":true,"id":"c7084419aa07","title":"6.remove(Object e)<br>"},{"parent":"a0987c4df8fe","children":[{"parent":"20c422a3a1d5","children":[],"id":"af6838db2c44","title":"// 从线性表中删除指定索引的元素\n    @Override\n    public Object remove(int i) {\n        // 判断是否越界\n        if (i &lt; 0 || i &gt;= size){\n            throw new IndexOutOfBoundsException(i + \"越界\");\n        }\n        Node pNode = head;\n        // 删除头结点(i为0时候)\n        if (i == 0){\n            head = head.next;\n            size--;\n            return pNode.data; // 返回删除头结点的数据\n        }\n        // 删除的是中间的元素，找到i-1结点\n        for (int j = 1; j &lt; i; j++) {\n            pNode = pNode.next;\n        }\n        // 保存删除结点的数据\n        Object old = pNode.next.data;\n        // 将i - 1 结点的next指针与改变一下(让i-1的next指向i+1结点，相当于删除了i)\n        pNode.next = pNode.next.next;\n        size--;\n        return old;\n    }"}],"collapsed":true,"id":"20c422a3a1d5","title":"7.remove(int i)"},{"parent":"a0987c4df8fe","children":[{"parent":"dcd9aef55e57","children":[],"id":"49705eb2fa7d","title":"// 把线性表中i索引值位置的元素替换为e\n    @Override\n    public Object replace(int i, Object e) {\n        // 判断是否越界\n        checkIndex(i);\n        // 找到i结点\n        Node pNode = getNode(i);\n        // 保存一下旧的数据\n        Object old = pNode.data;\n        // 替换\n        pNode.data = e;\n        return old;\n    }"}],"collapsed":true,"id":"dcd9aef55e57","title":"8.replace(int i, Object e)"},{"parent":"a0987c4df8fe","children":[{"parent":"63a0208a2ede","children":[],"id":"c9459ff00657","title":"// 返回线性表中i索引值的元素\n    @Override\n    public Object get(int i) {\n        // 判断是否越界\n        Node pNode = getNode(i);\n        return pNode.data;\n    }"}],"collapsed":true,"id":"63a0208a2ede","title":"9.get(int i)<br>"},{"parent":"a0987c4df8fe","children":[{"parent":"65cfed10551b","children":[],"id":"2e314bcf0f69","title":"// 在指定的元素p的前面插入元素e\n    @Override\n    public boolean insertBefore(Object p, Object e) {\n        // 找p的索引位置\n        int index = indexOf(p);\n        if (index &lt; 0){\n            // 元素p不存在\n            return false;\n        }\n        insert(index,e);\n        return true;\n    }"}],"collapsed":true,"id":"65cfed10551b","title":"10.insertBefore(Object p, Object e)"},{"parent":"a0987c4df8fe","children":[{"parent":"1adccd8e8fef","children":[],"id":"49699b181a66","title":"// 在指定的元素p的后面插入元素e\n    @Override\n    public boolean insertAfter(Object p, Object e) {\n        // 找p的索引位置\n        int index = indexOf(p);\n        if (index &lt; 0){\n            // 元素p不存在\n            return false;\n        }\n        insert(index + 1,e);\n        return true;\n    }"}],"collapsed":true,"id":"1adccd8e8fef","title":"11.insertAfter(Object p, Object e)"},{"parent":"a0987c4df8fe","children":[{"parent":"1163816c20f5","children":[],"id":"e35934ec507f","title":"// 重写toString()方法\n    @Override\n    public String toString() {\n        // 把链表中各个结点的数据与连接起来\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        Node pNode = head;\n        while (pNode != null){\n            sb.append(pNode.data);\n            // 使用逗号分割\n            if (pNode.next != null){\n                sb.append(\",\");\n            }\n            // 指针向后移动\n            pNode = pNode.next;\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }"}],"collapsed":true,"id":"1163816c20f5","title":"12.toString()<br>"},{"parent":"a0987c4df8fe","children":[{"parent":"37b970515deb","children":[],"id":"324410744faa","title":"// 定义一个方法来检查索引值是否越界\n    private void checkIndex(int i){\n        if (i &lt; 0 || i &gt;= size){\n            throw new IndexOutOfBoundsException(i + \"越界\");\n        }\n    }"}],"collapsed":true,"id":"37b970515deb","title":"13.private void checkIndex(int i)<br>"},{"parent":"a0987c4df8fe","children":[{"parent":"41a761d3adfc","children":[],"id":"d76e5f7d3514","title":"// 定义一个方法返回i索引值的元素\n    private Node getNode(int i){\n        if (i &lt; 0 || i&gt;= size){\n            return null;\n        }\n        if (i == 0){\n            return head;\n        }\n        // 找到i结点\n        Node pNode = head;\n        for (int j = 0; j &lt; i; j++) {\n            pNode = pNode.next;\n        }\n        return pNode;\n    }"}],"collapsed":true,"id":"41a761d3adfc","title":"14.private Node getNode(int i)<br>"},{"parent":"a0987c4df8fe","children":[{"parent":"7a65e83fc392","children":[],"id":"f0b14463ed9c","title":"// 定义一个内部类表示单向链表中的结点\n    private class Node{\n        // 保存数据\n        Object data;\n        // 保存下一个结点的引用\n        Node next;\n        // 构造\n        public Node(Object data, Node next) {\n            this.data = data;\n            this.next = next;\n        }\n    }"}],"collapsed":true,"id":"7a65e83fc392","title":"*****15.private class Node"}],"collapsed":true,"id":"a0987c4df8fe","title":"各个功能模块代码"},{"parent":"ad3c087bfdc2","children":[{"parent":"2c3377f02c0e","children":[],"id":"cb334c3636f4","title":"package pers.chenjiahao.linearity.singlelinkimpl.test;<br><br>import pers.chenjiahao.linearity.singlelinkimpl.MySingleLink;<br><br>/**<br> * 测试单向链表<br> */<br>public class MySingleLinkTest {<br>    public static void main(String[] args) {<br>        // 创建链表<br>        MySingleLink link = new MySingleLink();<br>        // 判断链表是否为空<br>        System.out.println(link.isEmpty()); // true<br>        // 获取元素个数<br>        System.out.println(link.getSize());<br>        // 插入元素<br>        link.insert(0,\"aa\");<br>        link.insert(0,\"bb\");<br>        link.insert(0,\"cc\");<br>        link.insert(0,\"dd\");<br>        // 直接打印输出<br>        System.out.println(link); // [dd,cc,bb,aa]<br>        // 判断元素是否存在<br>        System.out.println(link.indexOf(\"dd\")); // 0<br>        System.out.println(link.indexOf(\"aa\")); // 3<br>        System.out.println(link.indexOf(\"xx\")); // -1<br>        System.out.println(link.contains(\"cc\")); // true<br>        // 删除结点<br>        System.out.println(link.remove(\"xx\")); // null<br>        System.out.println(link.remove(\"bb\")); // bb<br>        System.out.println(link); // [dd,cc,aa]<br>        System.out.println(link.remove(0));<br>        System.out.println(link); // [cc,aa]<br>        // 返回元素，元素替换<br>        System.out.println(link.get(0)); // cc<br>        System.out.println(link.replace(0,\"CC\")); // cc<br>        System.out.println(link); // [CC,aa]<br>        // 在指定元素的前面/后面插入元素<br>        link.insertBefore(\"aa\",\"bb\");<br>        link.insertAfter(\"bb\",\"BB\");<br>        System.out.println(link); // [CC,bb,BB,aa]<br>        MySingleLink link2 = new MySingleLink();<br>    }<br>}<br>"}],"collapsed":true,"id":"2c3377f02c0e","title":"测试类"}],"collapsed":false,"id":"ad3c087bfdc2","title":"代码实现"}],"collapsed":false,"id":"400087c20a55","title":"单向链表"},{"parent":"07a1363cbe04","children":[{"parent":"bf4c19515ddc","children":[{"parent":"8ca292b6af9c","children":[],"id":"d229fa13fd41","title":"双向链表中，扩展了结点的结构，每个结点除了存储数据外，通过一个引用指向后继结点，再定义一个引用指向前驱结点"},{"parent":"8ca292b6af9c","image":{"w":515,"h":123,"url":"http://cdn.processon.com/5fdc54d9e401fd5bc82cf784?e=1608278761&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:-6ONXC_0jVRlm-lUoDFSPDg0sDU="},"children":[],"id":"3b491b9f468b","title":"图解"}],"collapsed":false,"id":"8ca292b6af9c","title":"基本概念"},{"parent":"bf4c19515ddc","children":[{"parent":"52144ffe5f0a","children":[{"image":{"w":673,"h":260,"url":"http://cdn.processon.com/5fdc5534f346fb1e546e2d8f?e=1608278852&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:3NH6a1nUj0jUv-priwDhfzxmkUU="},"parent":"a1f2eedbe04a","children":[],"id":"fdbce7d5857b","title":"图解"}],"collapsed":false,"id":"a1f2eedbe04a","title":"插入和删除元素"}],"collapsed":false,"id":"52144ffe5f0a","title":"原理"},{"parent":"bf4c19515ddc","children":[{"parent":"c4830bf4685d","children":[],"id":"eeacb54bb107","title":"创建一个MyDualLinkedList类，实现MyList接口"},{"parent":"c4830bf4685d","children":[{"parent":"381e786f5ff2","children":[],"id":"75639917e814","title":"package pers.chenjiahao.linearity.duallinkedlistimpl;\n\nimport pers.chenjiahao.linearity.operator.MyList;\n\npublic class MyDualLinkedList implements MyList {\n    // 指向头结点\n    private Node first;\n    // 指向尾结点\n    private Node last;\n    // 保存元素的个数\n    private int size;\n\n    // 返回元素的个数\n    @Override\n    public int getSize() {\n        return size;\n    }\n\n    // 判断链表是否为空\n    @Override\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    // 在指定的索引值插入元素\n    @Override\n    public void insert(int i, Object e) {\n        // 判断是否越界\n        if (i &lt; 0 || i &gt; size){\n            throw new IndexOutOfBoundsException(i + \"越界\");\n        }\n        // 如果i==0，在头部添加元素\n        if (i == 0){\n            addFirst(e);\n        }else if (i == size){\n            // 如果i==size，表示在尾部添加元素\n            addLast(e);\n        }else{\n            // 找到i结点，在i结点的前面插入元素\n            Node pNode = getNode(i);\n            Node prevNode = pNode.prev;\n            // 生成新的结点\n            Node newNode = new Node(e,prevNode,pNode);\n            // 修改前驱结点的next指向新节点\n            prevNode.next = newNode;\n            // 修改后继结点的prev指向新节点\n            pNode.prev = newNode;\n            // 元素加一\n            size++;\n        }\n    }\n\n    // 返回索引值对应的结点\n    private Node getNode(int i) {\n        Node pNode = first;\n        for (int j = 0; j &lt; i; j++) {\n            pNode = pNode.next;\n        }\n        return pNode;\n    }\n\n    // 判断链表中是否包含指定的元素e，如果存在返回true\n    @Override\n    public boolean contains(Object e) {\n        return indexOf(e) &gt;= 0;\n    }\n\n    // 判断元素e在链表中第一次出现的位置，如果不存在该元素，返回-1\n    @Override\n    public int indexOf(Object e) {\n        // 保存元素e在链表中的索引值\n        int i = 0;\n        // 依次遍历链表中的各个结点，比较结点的元素与指定的e是否一样\n        if (e == null){\n            for(Node pNode = first; pNode != null ; pNode = pNode.next){\n                if (pNode.data == null){\n                    return i;\n                }\n                i++;\n            }\n        }else{\n            for(Node pNode = first; pNode != null ; pNode = pNode.next){\n                if (e.equals(pNode.data)){\n                    return i;\n                }\n                i++;\n            }\n        }\n        return -1;\n    }\n\n    // 从链表中删除指定的元素\n    @Override\n    public Object remove(Object e) {\n        // 先找到元素e对应的索引值\n        int index = indexOf(e);\n        if (index &lt; 0){\n            return null;\n        }\n        return remove(index);\n    }\n\n    // 从链表中删除指定索引值的元素，并返回删除的元素\n    @Override\n    public Object remove(int i) {\n        // 判断索引值是否越界\n        if (i &lt; 0 || i &gt;= size){\n            throw new IndexOutOfBoundsException(i + \"越界\");\n        }\n        // 找到i对应的结点\n        Node pNode = getNode(i);\n        // 删除结点的前驱\n        Node prevNode = pNode.prev;\n        // 删除结点的后继\n        Node nextNode = pNode.next;\n        // 如果前驱结点为null\n        if (prevNode == null){\n            // 删除的就是头结点\n            first = nextNode;\n        }else {\n            // 将prevNode中的next指向nextNode\n            prevNode.next = nextNode;\n        }\n        // 如果后继节点为null\n        if (nextNode == null){\n            // 删除的就是尾结点\n            last = prevNode;\n        }else {\n            // 将nextNode中的prev指向prevNode\n            nextNode.prev = prevNode;\n        }\n        // 修改元素的个数\n        size--;\n        return pNode.data;\n    }\n\n    // 修改指定索引值的元素，将原来的元素返回\n    @Override\n    public Object replace(int i, Object e) {\n        // 检查索引值是否越界\n        checkIndex(i);\n        // 找到索引值为i的结点\n        Node pNode = getNode(i);\n        // 存储原来的元素\n        Object oldData = pNode.data;\n        // 修改结点的元素\n        pNode.data = e;\n        return oldData;\n    }\n\n    // 返回指定索引值的元素\n    @Override\n    public Object get(int i) {\n        // 检查索引值是否越界\n        checkIndex(i);\n        // 找到索引值为i的结点\n        return getNode(i).data;\n    }\n\n    // 在指定的元素p前面插入元素e\n    @Override\n    public boolean insertBefore(Object p, Object e) {\n        // 找到p元素在哪\n        int index = indexOf(p);\n        if (index &lt; 0 ){\n            return false;\n        }\n        // 在p元素的前面插入元素e\n        insert(index,e);\n        return true;\n    }\n\n    // 在指定的元素后面插入元素e\n    @Override\n    public boolean insertAfter(Object p, Object e) {\n        // 找到p元素在哪\n        int index = indexOf(p);\n        if (index &lt; 0 ){\n            return false;\n        }\n        // 在p元素的前面插入元素e\n        insert(index + 1,e);\n        return true;\n    }\n\n    // 校验是否越界的方法\n    private void checkIndex(int i){\n        if (i &lt; 0 || i &gt;= size){\n            throw new IndexOutOfBoundsException(i + \"越界\");\n        }\n    }\n\n// 在链表中，经常会有针对头元素与尾元素的操作\n    // 在尾部添加元素e\n    public void addLast(Object e) {\n        Node pNode = last;\n        // 生成一个新的结点\n        Node newNode = new Node(e,last,null);\n        if (pNode == null){\n            // 既是为结点，也是头结点\n            first = newNode;\n        }else {\n            pNode.next = newNode;\n        }\n        last = newNode;\n        size++;\n    }\n\n    // 在头部添加元素e\n    public void addFirst(Object e) {\n        // 生成一个新的结点\n        Node newNode = new Node(e,null,first);\n        /* 这种写法，如果first不存在，则会产生，空指针异常\n        // 将原先头结点的前驱指向这个新的结点\n        first.prev = newNode;\n        // 将头节点的指针指向这个新的结点\n        first = newNode;*/\n\n        // 修改first指向新的结点\n        first = newNode;\n        Node pNode = first.next;\n        // 刚刚插入的头结点，既是头节点，也是尾节点\n        if (pNode == null){\n            last = newNode;\n        }else {\n            pNode.prev = newNode;\n        }\n        // 元素的个数+1\n        size++;\n    }\n\n    // 删除第一个元素，删除头元素\n    public Object removeFirst(){\n        return remove(0);\n    }\n\n    // 删除最后一个元素，删除尾元素\n    public Object removeLast(){\n        return remove(size - 1);\n    }\n\n    // 返回头元素\n    public Object getFirst(){\n        return get(0);\n    }\n\n    // 返回尾元素\n    public Object getLast(){\n        return get(size - 1);\n    }\n\n    // 重写toString\n    @Override\n    public String toString() {\n        // 依次遍历各个节点，把元素转换为字符串\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (Node node = first; node != null ; node = node.next) {\n            sb.append(node.data);\n            // 元素之间使用逗号分割\n            if (node != last){\n                sb.append(\",\");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    // 定义一个内部类描述双向链表的结点\n    private class Node{\n        // 保存数据域\n        private Object data;\n        // 保存前驱结点\n        private Node prev;\n        // 保存后继结点\n        private Node next;\n\n        public Node(Object data, Node prev, Node next) {\n            this.data = data;\n            this.prev = prev;\n            this.next = next;\n        }\n    }\n}\n"}],"collapsed":true,"id":"381e786f5ff2","title":"完整代码"},{"parent":"c4830bf4685d","children":[{"parent":"2c286ddc2bed","children":[{"parent":"fd262d44af34","children":[],"id":"04c4cc85521c","title":"// 返回元素的个数<br>    @Override<br>    public int getSize() {<br>        return size;<br>    }"}],"collapsed":true,"id":"fd262d44af34","title":"1.getSize()<br>"},{"parent":"2c286ddc2bed","children":[{"parent":"add6a2e8151a","children":[],"id":"3ecc224c37ed","title":"// 判断链表是否为空<br>    @Override<br>    public boolean isEmpty() {<br>        return size == 0;<br>    }"}],"collapsed":true,"id":"add6a2e8151a","title":"2.isEmpty()<br>"},{"parent":"2c286ddc2bed","children":[{"parent":"e19310b3c4de","children":[],"id":"8f2a972f2b1f","title":"// 在指定的索引值插入元素\n    @Override\n    public void insert(int i, Object e) {\n        // 判断是否越界\n        if (i &lt; 0 || i &gt; size){\n            throw new IndexOutOfBoundsException(i + \"越界\");\n        }\n        // 如果i==0，在头部添加元素\n        if (i == 0){\n            addFirst(e);\n        }else if (i == size){\n            // 如果i==size，表示在尾部添加元素\n            addLast(e);\n        }else{\n            // 找到i结点，在i结点的前面插入元素\n            Node pNode = getNode(i);\n            Node prevNode = pNode.prev;\n            // 生成新的结点\n            Node newNode = new Node(e,prevNode,pNode);\n            // 修改前驱结点的next指向新节点\n            prevNode.next = newNode;\n            // 修改后继结点的prev指向新节点\n            pNode.prev = newNode;\n            // 元素加一\n            size++;\n        }\n    }"}],"collapsed":true,"id":"e19310b3c4de","title":"3.insert(int i, Object e)<br>"},{"parent":"2c286ddc2bed","children":[{"parent":"347b833967b9","children":[],"id":"03593d6b2e8f","title":"// 判断链表中是否包含指定的元素e，如果存在返回true\n    @Override\n    public boolean contains(Object e) {\n        return indexOf(e) &gt;= 0;\n    }"}],"collapsed":true,"id":"347b833967b9","title":"4.contains(Object e)"},{"parent":"2c286ddc2bed","children":[{"parent":"d4a216b016b3","children":[],"id":"453321eba950","title":"// 判断元素e在链表中第一次出现的位置，如果不存在该元素，返回-1\n    @Override\n    public int indexOf(Object e) {\n        // 保存元素e在链表中的索引值\n        int i = 0;\n        // 依次遍历链表中的各个结点，比较结点的元素与指定的e是否一样\n        if (e == null){\n            for(Node pNode = first; pNode != null ; pNode = pNode.next){\n                if (pNode.data == null){\n                    return i;\n                }\n                i++;\n            }\n        }else{\n            for(Node pNode = first; pNode != null ; pNode = pNode.next){\n                if (e.equals(pNode.data)){\n                    return i;\n                }\n                i++;\n            }\n        }\n        return -1;\n    }"}],"collapsed":true,"id":"d4a216b016b3","title":"5.indexOf(Object e)"},{"parent":"2c286ddc2bed","children":[{"parent":"dfe7575dc8a1","children":[],"id":"0fb504dee488","title":"// 从链表中删除指定的元素\n    @Override\n    public Object remove(Object e) {\n        // 先找到元素e对应的索引值\n        int index = indexOf(e);\n        if (index &lt; 0){\n            return null;\n        }\n        return remove(index);\n    }"}],"collapsed":true,"id":"dfe7575dc8a1","title":"6.remove(Object e)<br>"},{"parent":"2c286ddc2bed","children":[{"parent":"d409e638c2ce","children":[],"id":"12243e58af5e","title":"// 从链表中删除指定索引值的元素，并返回删除的元素\n    @Override\n    public Object remove(int i) {\n        // 判断索引值是否越界\n        if (i &lt; 0 || i &gt;= size){\n            throw new IndexOutOfBoundsException(i + \"越界\");\n        }\n        // 找到i对应的结点\n        Node pNode = getNode(i);\n        // 删除结点的前驱\n        Node prevNode = pNode.prev;\n        // 删除结点的后继\n        Node nextNode = pNode.next;\n        // 如果前驱结点为null\n        if (prevNode == null){\n            // 删除的就是头结点\n            first = nextNode;\n        }else {\n            // 将prevNode中的next指向nextNode\n            prevNode.next = nextNode;\n        }\n        // 如果后继节点为null\n        if (nextNode == null){\n            // 删除的就是尾结点\n            last = prevNode;\n        }else {\n            // 将nextNode中的prev指向prevNode\n            nextNode.prev = prevNode;\n        }\n        // 修改元素的个数\n        size--;\n        return pNode.data;\n    }"}],"collapsed":true,"id":"d409e638c2ce","title":"7.remove(int i)"},{"parent":"2c286ddc2bed","children":[{"parent":"67aa6b964c52","children":[],"id":"bf59ed0dd056","title":"// 修改指定索引值的元素，将原来的元素返回\n    @Override\n    public Object replace(int i, Object e) {\n        // 检查索引值是否越界\n        checkIndex(i);\n        // 找到索引值为i的结点\n        Node pNode = getNode(i);\n        // 存储原来的元素\n        Object oldData = pNode.data;\n        // 修改结点的元素\n        pNode.data = e;\n        return oldData;\n    }"}],"collapsed":true,"id":"67aa6b964c52","title":"8.replace(int i, Object e)"},{"parent":"2c286ddc2bed","children":[{"parent":"9cb27c250765","children":[],"id":"dcc4e8a444d6","title":"// 返回指定索引值的元素\n    @Override\n    public Object get(int i) {\n        // 检查索引值是否越界\n        checkIndex(i);\n        // 找到索引值为i的结点\n        return getNode(i).data;\n    }"}],"collapsed":true,"id":"9cb27c250765","title":"9.get(int i)<br>"},{"parent":"2c286ddc2bed","children":[{"parent":"a01dd29ae8e2","children":[],"id":"413290a74f45","title":"// 在指定的元素p前面插入元素e\n    @Override\n    public boolean insertBefore(Object p, Object e) {\n        // 找到p元素在哪\n        int index = indexOf(p);\n        if (index &lt; 0 ){\n            return false;\n        }\n        // 在p元素的前面插入元素e\n        insert(index,e);\n        return true;\n    }"}],"collapsed":true,"id":"a01dd29ae8e2","title":"10.insertBefore(Object p, Object e)"},{"parent":"2c286ddc2bed","children":[{"parent":"4e93c68b5b39","children":[],"id":"e51f30846de3","title":"// 在指定的元素后面插入元素e\n    @Override\n    public boolean insertAfter(Object p, Object e) {\n        // 找到p元素在哪\n        int index = indexOf(p);\n        if (index &lt; 0 ){\n            return false;\n        }\n        // 在p元素的前面插入元素e\n        insert(index + 1,e);\n        return true;\n    }"}],"collapsed":true,"id":"4e93c68b5b39","title":"11.insertAfter(Object p, Object e)"},{"parent":"2c286ddc2bed","children":[{"parent":"30c965ac0cf6","children":[],"id":"69963ef3b920","title":"// 重写toString\n    @Override\n    public String toString() {\n        // 依次遍历各个节点，把元素转换为字符串\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (Node node = first; node != null ; node = node.next) {\n            sb.append(node.data);\n            // 元素之间使用逗号分割\n            if (node != last){\n                sb.append(\",\");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }"}],"collapsed":true,"id":"30c965ac0cf6","title":"12.toString()<br>"},{"parent":"2c286ddc2bed","children":[{"parent":"307ca363e96e","children":[],"id":"87efb0c104b0","title":"// 校验是否越界的方法<br>    private void checkIndex(int i){<br>        if (i &lt; 0 || i &gt;= size){<br>            throw new IndexOutOfBoundsException(i + \"越界\");<br>        }<br>    }"}],"collapsed":true,"id":"307ca363e96e","title":"13.private void checkIndex(int i)<br>"},{"parent":"2c286ddc2bed","children":[{"parent":"76aa7cd41a3c","children":[],"id":"1131f8713325","title":"// 返回索引值对应的结点\n    private Node getNode(int i) {\n        Node pNode = first;\n        for (int j = 0; j &lt; i; j++) {\n            pNode = pNode.next;\n        }\n        return pNode;\n    }"}],"collapsed":true,"id":"76aa7cd41a3c","title":"14.private Node getNode(int i)<br>"},{"parent":"2c286ddc2bed","children":[{"parent":"73a245ef4c9f","children":[],"id":"b2032615b399","title":"// 定义一个内部类描述双向链表的结点<br>    private class Node{<br>        // 保存数据域<br>        private Object data;<br>        // 保存前驱结点<br>        private Node prev;<br>        // 保存后继结点<br>        private Node next;<br><br>        public Node(Object data, Node prev, Node next) {<br>            this.data = data;<br>            this.prev = prev;<br>            this.next = next;<br>        }<br>    }"}],"collapsed":true,"id":"73a245ef4c9f","title":"*****15.private class Node<br>"},{"parent":"2c286ddc2bed","children":[{"parent":"1258a00c3aa6","children":[{"parent":"ead2cc92d128","children":[],"id":"b946f5fcf65a","title":"// 在头部添加元素e\n    public void addFirst(Object e) {\n        // 生成一个新的结点\n        Node newNode = new Node(e,null,first);\n        /* 这种写法，如果first不存在，则会产生，空指针异常\n        // 将原先头结点的前驱指向这个新的结点\n        first.prev = newNode;\n        // 将头节点的指针指向这个新的结点\n        first = newNode;*/\n\n        // 修改first指向新的结点\n        first = newNode;\n        Node pNode = first.next;\n        // 刚刚插入的头结点，既是头节点，也是尾节点\n        if (pNode == null){\n            last = newNode;\n        }else {\n            pNode.prev = newNode;\n        }\n        // 元素的个数+1\n        size++;\n    }"}],"collapsed":true,"id":"ead2cc92d128","title":"addFirst(Object e)<br>"},{"parent":"1258a00c3aa6","children":[{"parent":"395f81223fef","children":[],"id":"789c358fde73","title":"// 在尾部添加元素e\n    public void addLast(Object e) {\n        Node pNode = last;\n        // 生成一个新的结点\n        Node newNode = new Node(e,last,null);\n        if (pNode == null){\n            // 既是为结点，也是头结点\n            first = newNode;\n        }else {\n            pNode.next = newNode;\n        }\n        last = newNode;\n        size++;\n    }"}],"collapsed":true,"id":"395f81223fef","title":"addLast(Object e)<br>"},{"parent":"1258a00c3aa6","children":[{"parent":"70b4df8c53f6","children":[],"id":"1f0efa37be0d","title":"// 删除第一个元素，删除头元素<br>    public Object removeFirst(){<br>        return remove(0);<br>    }"}],"collapsed":true,"id":"70b4df8c53f6","title":"removeFirst()<br>"},{"parent":"1258a00c3aa6","children":[{"parent":"1d4ef31dde07","children":[],"id":"0d0e025e052b","title":"// 删除最后一个元素，删除尾元素<br>    public Object removeLast(){<br>        return remove(size - 1);<br>    }"}],"collapsed":true,"id":"1d4ef31dde07","title":"removeLast()<br>"},{"parent":"1258a00c3aa6","children":[{"parent":"55af397074b8","children":[],"id":"c38ce6d52e70","title":"// 返回头元素<br>    public Object getFirst(){<br>        return get(0);<br>    }"}],"collapsed":true,"id":"55af397074b8","title":"getFirst()<br>"},{"parent":"1258a00c3aa6","children":[{"parent":"e6f21c233bab","children":[],"id":"a826ec134bf3","title":"// 返回尾元素\n    public Object getLast(){\n        return get(size - 1);\n    }"}],"collapsed":true,"id":"e6f21c233bab","title":"getLast()<br>"}],"collapsed":true,"id":"1258a00c3aa6","title":"在链表中，经常会有针对头元素与尾元素的操作"}],"collapsed":true,"id":"2c286ddc2bed","title":"各个功能模块代码"},{"parent":"c4830bf4685d","children":[{"parent":"b84cd55a821e","children":[],"id":"3a94964a3102","title":"package pers.chenjiahao.linearity.duallinkedlistimpl.test;\n\nimport pers.chenjiahao.linearity.duallinkedlistimpl.MyDualLinkedList;\n\npublic class MyDualLinkedListTest {\n    public static void main(String[] args) {\n        // 创建双向链表\n        MyDualLinkedList linkedList = new MyDualLinkedList();\n        System.out.println(linkedList.getSize());\n        System.out.println(linkedList.isEmpty());\n\n        linkedList.insert(0,\"gg\");\n        linkedList.insert(0,\"jj\");\n        linkedList.insert(1,\"dd\");\n        linkedList.insert(3,\"mm\");\n        System.out.println(linkedList);\n\n        // 测试是否包含某个元素\n        System.out.println(linkedList.indexOf(\"jj\"));\n        System.out.println(linkedList.indexOf(\"mm\"));\n        System.out.println(linkedList.indexOf(\"DD\"));\n        System.out.println(linkedList.contains(\"xx\"));\n        System.out.println(linkedList.contains(\"gg\"));\n\n        // 删除指定的结点\n        System.out.println(linkedList.remove(0));\n        System.out.println(linkedList);\n        System.out.println(linkedList.remove(\"mm\"));\n        System.out.println(linkedList);\n\n        linkedList.replace(0,\"xx\");\n        System.out.println(linkedList.get(1));\n        System.out.println(linkedList);\n\n        linkedList.insertBefore(\"xx\",\"yy\");\n        linkedList.insertBefore(\"xx\",\"oo\");\n        System.out.println(linkedList); // [yy,oo,xx,gg]\n\n        linkedList.addFirst(\"TT\");\n        linkedList.addLast(\"MM\");\n        System.out.println(linkedList);\n        System.out.println(linkedList.getFirst());\n        System.out.println(linkedList.getLast());\n        System.out.println(linkedList.removeFirst());\n        System.out.println(linkedList.removeLast());\n        System.out.println(linkedList);\n\n    }\n}\n"}],"collapsed":true,"id":"b84cd55a821e","title":"测试类"}],"collapsed":true,"id":"c4830bf4685d","title":"代码实现"}],"collapsed":false,"id":"bf4c19515ddc","title":"双向链表"}],"collapsed":false,"id":"07a1363cbe04","title":"线性表的链式存储"},{"parent":"458330585163","children":[{"parent":"c75fdbe59696","children":[{"parent":"d994a9e298a8","children":[],"id":"650ee15513bc","title":"线性表的基本操作：查询、插入、删除"},{"parent":"d994a9e298a8","children":[{"parent":"1c533a8ce0a2","children":[{"parent":"13ce673e1a65","children":[],"id":"ced1b523c851","title":"直接通过索引值访问每个元素，实现了数组元素的随机访问"}],"collapsed":false,"id":"13ce673e1a65","title":"顺序存储"},{"parent":"1c533a8ce0a2","children":[{"parent":"4800cea1a152","children":[],"id":"c760b16a1ff4","title":"每次都要从头结点或尾结点开始依次查找"}],"id":"4800cea1a152","title":"链式存储"}],"id":"1c533a8ce0a2","title":"查询"},{"parent":"d994a9e298a8","children":[{"parent":"9cbf83ffc3fb","children":[{"parent":"da65a92d85a0","children":[],"id":"dd7dff780efa","title":"需要移动大量的元素"}],"id":"da65a92d85a0","title":"顺序存储"},{"parent":"9cbf83ffc3fb","children":[{"parent":"1fe9dcb6f2d0","children":[],"id":"2e6e439d6ef9","title":"只需要修改结点的前驱和后继指针即可，不需要移动元素"}],"id":"1fe9dcb6f2d0","title":"链式存储"}],"id":"9cbf83ffc3fb","title":"插入与删除"},{"parent":"d994a9e298a8","children":[{"parent":"edde9cb31958","children":[{"parent":"db053a8dff97","children":[],"id":"25135ac27b98","title":"优先选择顺序存储"}],"id":"db053a8dff97","title":"查询操作多"},{"parent":"edde9cb31958","children":[{"parent":"a738208bf789","children":[],"id":"5b3ba9b83309","title":"优先选择链式存储"}],"id":"a738208bf789","title":"插入与删除操作多"}],"id":"edde9cb31958","title":"总结"}],"id":"d994a9e298a8","title":"时间上"},{"parent":"c75fdbe59696","children":[{"parent":"374fde16a952","children":[{"parent":"cd71b9fb8a17","children":[],"id":"a1bbd5925874","title":"预先分配一块连续的存储空间，在使用过程中会出现闲置的空间"}],"id":"cd71b9fb8a17","title":"顺序存储"},{"parent":"374fde16a952","children":[{"parent":"e0d63254f0e0","children":[],"id":"05247f1773cd","title":"存储空间是动态分配的，不会浪费空间"}],"id":"e0d63254f0e0","title":"链式存储"},{"parent":"374fde16a952","children":[{"parent":"bf8db5fd10e4","children":[],"id":"0ba97d8bae52","title":"如果线性表的长度经常变化，优先选择链式存储"},{"parent":"bf8db5fd10e4","children":[],"id":"8b882326ed55","title":"如果线性表的长度变化不大，优先选择顺序存储"}],"id":"bf8db5fd10e4","title":"总结"}],"id":"374fde16a952","title":"空间上"}],"collapsed":false,"id":"c75fdbe59696","title":"顺序存储与链式存储实现线性表的比较"}],"collapsed":true,"id":"458330585163","title":"3.线性表","summaries":[]},{"parent":"270b57d67f7f","children":[{"parent":"cec51a1841f6","children":[],"id":"f17eb2e6ae30","title":"栈与队列，从逻辑结构上看，也是线性结构，是操作受限的线性结构"},{"parent":"cec51a1841f6","children":[{"parent":"492fd1d10622","children":[{"parent":"a3aed933d06c","children":[],"id":"dee8a19414ef","title":"栈(Stack)，也称堆栈，是一种操作受限的线性表。<br>"},{"parent":"a3aed933d06c","children":[],"id":"29c05419d783","title":"栈只允许在线性表的一段进行插入/删除等操作，不允许在其他位置插入/删除"},{"parent":"a3aed933d06c","children":[],"id":"dad6d052bb09","title":"在线性表中进行插入/删除的一段称为栈顶(top),栈顶保存的元素称为栈顶元素，相对的另一端称为栈底(bottom)"},{"parent":"a3aed933d06c","children":[],"id":"1737752d63d2","title":"如果栈中没有数据元素称为空栈"},{"parent":"a3aed933d06c","children":[],"id":"771f2cff23b1","title":"向栈中插入元素，称为进栈/入栈/压栈，从栈中删除元素称退栈/出栈/弹栈"},{"parent":"a3aed933d06c","children":[],"id":"6fa9300ce07e","title":"栈的插入/删除操作只允许在栈顶进行，后进栈的元素必定先出栈，称为先进后出或后进先出<br>"},{"image":{"w":558,"h":195,"url":"http://cdn.processon.com/5fdcc2505653bb4ccf2f78c3?e=1608306784&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Wx-mcYGYeFi3E1aDlW7PhOGJIss="},"parent":"a3aed933d06c","children":[],"id":"2053ea83c649","title":"图解"}],"collapsed":false,"id":"a3aed933d06c","title":"基本概念"},{"parent":"492fd1d10622","children":[{"parent":"23b15fcfd760","children":[],"id":"38771f0ff79a","title":"ADT Stack{<br>&nbsp; &nbsp; &nbsp; &nbsp;数据对象：D = {a0,a1,a2...an,ai是同一种数据类型的元素}<br>&nbsp; &nbsp; &nbsp; &nbsp;数据关系：R = {&lt;ai,a(i+1)&gt;}<br>&nbsp; &nbsp; &nbsp; &nbsp;基本操作：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getSize() 返回元素的个数<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isEmpty()判断堆栈是否为空<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push(Object e) 压栈<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop()&nbsp; 弹栈<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;peek() 返回栈顶元素<br>}"}],"collapsed":false,"id":"23b15fcfd760","title":"堆栈抽象数据类型"},{"parent":"492fd1d10622","children":[{"parent":"9d59f4788af3","children":[],"id":"d06fc72a8ea3","title":"package pers.chenjiahao.linearity.stackoperator;<br><br>/**<br> * 定义接口，定义栈的操作<br> */<br>public interface MyStack {<br>    int getSize(); // 判断栈的长度<br>    boolean isEmpty(); // 判断栈是否为空<br>    void push(Object e); // 压栈，入栈<br>    Object pop(); // 弹栈，出栈<br>    Object peek(); // 返回栈顶元素<br>}<br>"}],"collapsed":false,"id":"9d59f4788af3","title":"MyStack接口"},{"parent":"492fd1d10622","children":[{"parent":"9c7d90b4bcc8","children":[{"parent":"812c77bbf13a","children":[],"id":"81fc0f43cd1d","title":"顺序栈可以通过数组存储堆栈的元素"},{"parent":"812c77bbf13a","children":[],"id":"50919c5cd2c8","title":"堆栈的操作都在栈顶完成，选择数组中索引值较大的一端作为栈顶"}],"collapsed":false,"id":"812c77bbf13a","title":"基本概念"},{"parent":"9c7d90b4bcc8","children":[{"parent":"e9fce9575878","children":[],"id":"74f6bc1bff8b","title":"创建一个MyArrayStack类，实现MyStack接口"},{"parent":"e9fce9575878","children":[{"parent":"69d8448803a4","children":[],"id":"58de7384910b","title":"package pers.chenjiahao.linearity.arraystack;<br><br>import pers.chenjiahao.linearity.stackoperator.MyStack;<br><br>/**<br> * 栈的顺序实现<br> */<br>public class MyArrayStack implements MyStack {<br>    // 定义数组来保存栈的元素<br>    private Object[] elements;<br>    // 栈的默认容量<br>    private static final int DEFAULT_CAPACITY = 16;<br>    // 栈顶指针<br>    private int top;<br><br>    // 无参构造中，对数组默认初始化<br>    public MyArrayStack() {<br>        elements = new Object[DEFAULT_CAPACITY];<br>    }<br><br>    // 有参构造中，指定栈的初始化大小<br>    public MyArrayStack(int initialCapacity) {<br>        elements = new Object[initialCapacity];<br>    }<br><br>    // 返回元素的个数<br>    @Override<br>    public int getSize() {<br>        return top;<br>    }<br><br>    // 判断栈中是否为空<br>    @Override<br>    public boolean isEmpty() {<br>        return top &lt;= 0;<br>    }<br><br>    // 入栈/压栈<br>    @Override<br>    public void push(Object e) {<br>        // 判断栈是否已满，如果已满，数组需要扩容<br>        if (top &gt;= elements.length){<br>            // 定义一个更大的数组<br>            Object[] newData = new Object[elements.length * 2];<br>            // 将原来的数组的内容复制到大的数组中<br>            for (int i = 0; i &lt; elements.length; i++) {<br>                newData[i] = elements[i];<br>            }<br>            // 让原来的数组名指向新的数组<br>            elements = newData;<br>        }<br>        // 把元素存储到栈顶指针指向的位置<br>        elements[top] = e;<br>        // 栈顶指针上移<br>        top++;<br>    }<br><br>    // 出栈/弹栈<br>    @Override<br>    public Object pop() {<br>        // 判断栈是否为空<br>        if (top &lt;= 0){<br>            throw new StackOverflowError(\"栈已空\");<br>        }<br>        top--; // 栈顶指针下移<br>        return elements[top];<br>    }<br><br>    // 返回栈顶元素,不删除<br>    @Override<br>    public Object peek() {<br>        // 判断栈是否为空<br>        if (top &lt;= 0){<br>            throw new StackOverflowError(\"栈已空\");<br>        }<br>        return elements[top - 1];<br>    }<br><br>    // 重写toString()，从栈顶到占底输出<br>    @Override<br>    public String toString() {<br>        StringBuilder sb = new StringBuilder();<br>        sb.append(\"[\");<br>        // 从栈顶到占地的顺序添加各个元素<br>        for (int i = top - 1; i &gt;= 0; i--) {<br>            sb.append(elements[i]);<br>            // 元素之间用逗号分割<br>            if (i &gt; 0){<br>                sb.append(\",\");<br>            }<br>        }<br>        sb.append(\"]\");<br>        return sb.toString();<br>    }<br>}<br>"}],"collapsed":true,"id":"69d8448803a4","title":"完整代码<br>"},{"parent":"e9fce9575878","children":[{"parent":"5d4653644b24","children":[{"parent":"84973857eb01","children":[],"id":"010d8ae30e26","title":"// 返回元素的个数\n    @Override\n    public int getSize() {\n        return top;\n    }"}],"collapsed":true,"id":"84973857eb01","title":"1.getSize()"},{"parent":"5d4653644b24","children":[{"parent":"24f603390117","children":[],"id":"8e8df7defe5b","title":"// 判断栈中是否为空\n    @Override\n    public boolean isEmpty() {\n        return top &lt;= 0;\n    }"}],"collapsed":true,"id":"24f603390117","title":"2.isEmpty()"},{"parent":"5d4653644b24","children":[{"parent":"0c73c2eeab7e","children":[],"id":"5317d47272ba","title":"// 入栈/压栈\n    @Override\n    public void push(Object e) {\n        // 判断栈是否已满，如果已满，数组需要扩容\n        if (top &gt;= elements.length){\n            // 定义一个更大的数组\n            Object[] newData = new Object[elements.length * 2];\n            // 将原来的数组的内容复制到大的数组中\n            for (int i = 0; i &lt; elements.length; i++) {\n                newData[i] = elements[i];\n            }\n            // 让原来的数组名指向新的数组\n            elements = newData;\n        }\n        // 把元素存储到栈顶指针指向的位置\n        elements[top] = e;\n        // 栈顶指针上移\n        top++;\n    }"}],"collapsed":true,"id":"0c73c2eeab7e","title":"3.push(Object e)"},{"parent":"5d4653644b24","children":[{"parent":"70c0fe4b104c","children":[],"id":"48383b1d4f6a","title":"// 出栈/弹栈\n    @Override\n    public Object pop() {\n        // 判断栈是否为空\n        if (top &lt;= 0){\n            throw new StackOverflowError(\"栈已空\");\n        }\n        top--; // 栈顶指针下移\n        return elements[top];\n    }"}],"collapsed":true,"id":"70c0fe4b104c","title":"4.pop()"},{"parent":"5d4653644b24","children":[{"parent":"baef6e531131","children":[],"id":"ccad848ee88f","title":"// 返回栈顶元素,不删除\n    @Override\n    public Object peek() {\n        // 判断栈是否为空\n        if (top &lt;= 0){\n            throw new StackOverflowError(\"栈已空\");\n        }\n        return elements[top - 1];\n    }"}],"collapsed":true,"id":"baef6e531131","title":"5.peek()"},{"parent":"5d4653644b24","children":[{"parent":"08aed731a7b8","children":[],"id":"08059b5677c1","title":"// 重写toString()，从栈顶到占底输出\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        // 从栈顶到占地的顺序添加各个元素\n        for (int i = top - 1; i &gt;= 0; i--) {\n            sb.append(elements[i]);\n            // 元素之间用逗号分割\n            if (i &gt; 0){\n                sb.append(\",\");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }"}],"collapsed":true,"id":"08aed731a7b8","title":"6.toString()"}],"collapsed":true,"id":"5d4653644b24","title":"各个功能模块代码"},{"parent":"e9fce9575878","children":[{"parent":"25e7cb459d9f","children":[],"id":"9fc6c3740683","title":"package pers.chenjiahao.linearity.arraystack.test;<br><br>import pers.chenjiahao.linearity.arraystack.MyArrayStack;<br><br>public class MyArrayStackTest {<br>    public static void main(String[] args) {<br>        // 创建栈<br>        MyArrayStack stack = new MyArrayStack();<br>        System.out.println(stack.isEmpty()); // true<br>        System.out.println(stack.getSize()); // 0<br>        // 压栈<br>        stack.push(\"aa\");<br>        stack.push(\"bb\");<br>        stack.push(\"cc\");<br>        stack.push(\"dd\");<br>        System.out.println(stack.isEmpty()); // false<br>        System.out.println(stack.getSize()); // 4<br>        // 重写toString方法<br>        System.out.println(stack); // [dd,cc,bb,aa]<br>        // 弹出栈顶元素<br>        System.out.println(stack.peek()); // dd<br>        // 出栈<br>        System.out.println(stack.pop()); // dd<br>        System.out.println(stack);<br>        System.out.println(stack.pop());<br>        System.out.println(stack.pop());<br>        System.out.println(stack.pop());<br>        System.out.println(stack);<br>    }<br>}<br>"}],"collapsed":true,"id":"25e7cb459d9f","title":"测试类<br>"}],"collapsed":true,"id":"e9fce9575878","title":"代码实现"}],"collapsed":false,"id":"9c7d90b4bcc8","title":"顺序实现<br>"},{"parent":"492fd1d10622","children":[{"parent":"ec030f3c33c0","children":[{"parent":"3cd8b7300eef","children":[],"id":"2164875f1373","title":"使用链表作为栈的存储结构，有时也成为链栈"},{"parent":"3cd8b7300eef","children":[],"id":"3272b3a3be49","title":"栈只允许在线性表的一端进行操作，可以选择链表的表头作为栈顶"},{"parent":"3cd8b7300eef","children":[],"id":"d7ceb6508b28","title":"第一个结点可以当作为栈底"},{"parent":"3cd8b7300eef","children":[],"id":"65ff67411e48","title":"不管是压栈还是弹栈，都要在链表的首结点进行"}],"collapsed":false,"id":"3cd8b7300eef","title":"基本概念"},{"parent":"ec030f3c33c0","children":[{"parent":"951bb2aa0763","children":[],"id":"91053a0b2b1d","title":"创建一个MyLinkStack类，实现MyStack接口"},{"parent":"951bb2aa0763","children":[{"parent":"63afbce0dcc8","children":[],"id":"92184d4c388f","title":"package pers.chenjiahao.linearity.linkstack;<br><br>import pers.chenjiahao.linearity.stackoperator.MyStack;<br><br>/**<br> * 栈的链式存储<br> * 注：第一个定义的结点，相当于就是栈底<br> */<br>public class MyLinkStack implements MyStack {<br>    // 存储栈顶的引用<br>    private Node top;<br>    // 保存栈中元素的个数<br>    private int size;<br><br>    // 返回栈中元素的个数<br>    @Override<br>    public int getSize() {<br>        return size;<br>    }<br><br>    // 判断栈是否为空<br>    @Override<br>    public boolean isEmpty() {<br>        return size == 0;<br>    }<br><br>    // 入栈/压栈<br>    @Override<br>    public void push(Object e) {<br>        // 根据元素生成结点，插入到链表的头部<br>        Node pNode = new Node(e,top);<br>        // 修改top栈顶指针,指向新的结点<br>        top = pNode;<br>        // 元素个数+1<br>        size++;<br>    }<br><br>    // 出栈/弹栈<br>    @Override<br>    public Object pop() {<br>        // 判断栈是否为空<br>        if (size &lt; 1){<br>            throw new StackOverflowError(\"栈已空\");<br>        }<br>        // 保存原来栈顶元素<br>        Object oldData = top.data;<br>        // 后移栈顶指针<br>        top = top.next;<br>        size--;<br>        return oldData;<br>    }<br><br>    // 返回栈顶元素<br>    @Override<br>    public Object peek() {<br>        // 判断栈是否为空<br>        if (size &lt; 1){<br>            throw new StackOverflowError(\"栈已空\");<br>        }<br>        return top.data;<br>    }<br><br>    // 重写toString方法<br>    @Override<br>    public String toString() {<br>        // 将链表中各个结点的数据给返回<br>        StringBuilder sb = new StringBuilder();<br>        sb.append(\"[\");<br>        for (Node pNode = top; pNode != null; pNode = pNode.next){<br>            sb.append(pNode.data);<br>            // 数据元素之间使用逗号分割<br>            if (pNode.next != null){<br>                sb.append(\",\");<br>            }<br>        }<br>        sb.append(\"]\");<br>        return sb.toString();<br>    }<br><br>    // 定义一个内部类，描述链表中的结点<br>    private class Node{<br>        // 存储数据<br>        Object data;<br>        // 存储下个结点的引用<br>        Node next;<br><br>        public Node() {<br>        }<br><br>        public Node(Object data, Node next) {<br>            this.data = data;<br>            this.next = next;<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"63afbce0dcc8","title":"完整代码<br>"},{"parent":"951bb2aa0763","children":[{"parent":"aeaff4bab5ed","children":[{"parent":"4efc61456b85","children":[],"id":"ddc329213cb1","title":"// 返回栈中元素的个数\n    @Override\n    public int getSize() {\n        return size;\n    }"}],"collapsed":true,"id":"4efc61456b85","title":"1.getSize()"},{"parent":"aeaff4bab5ed","children":[{"parent":"0beac5cd626b","children":[],"id":"f5b91bd9f31f","title":"// 判断栈是否为空\n    @Override\n    public boolean isEmpty() {\n        return size == 0;\n    }"}],"collapsed":true,"id":"0beac5cd626b","title":"2.isEmpty()"},{"parent":"aeaff4bab5ed","children":[{"parent":"736d0f8c2319","children":[],"id":"dbe05aeb4052","title":"// 入栈/压栈\n    @Override\n    public void push(Object e) {\n        // 根据元素生成结点，插入到链表的头部\n        Node pNode = new Node(e,top);\n        // 修改top栈顶指针,指向新的结点\n        top = pNode;\n        // 元素个数+1\n        size++;\n    }"}],"collapsed":true,"id":"736d0f8c2319","title":"3.push(Object e)"},{"parent":"aeaff4bab5ed","children":[{"parent":"3553d3fa2680","children":[],"id":"eec00a88b552","title":"// 出栈/弹栈\n    @Override\n    public Object pop() {\n        // 判断栈是否为空\n        if (size &lt; 1){\n            throw new StackOverflowError(\"栈已空\");\n        }\n        // 保存原来栈顶元素\n        Object oldData = top.data;\n        // 后移栈顶指针\n        top = top.next;\n        size--;\n        return oldData;\n    }"}],"collapsed":true,"id":"3553d3fa2680","title":"4.pop()"},{"parent":"aeaff4bab5ed","children":[{"parent":"5be05ae142fa","children":[],"id":"f2dc9418eab1","title":"// 返回栈顶元素\n    @Override\n    public Object peek() {\n        // 判断栈是否为空\n        if (size &lt; 1){\n            throw new StackOverflowError(\"栈已空\");\n        }\n        return top.data;\n    }"}],"collapsed":true,"id":"5be05ae142fa","title":"5.peek()"},{"parent":"aeaff4bab5ed","children":[{"parent":"9e8f1fca2d35","children":[],"id":"be5f8e464748","title":"// 重写toString方法\n    @Override\n    public String toString() {\n        // 将链表中各个结点的数据给返回\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (Node pNode = top; pNode != null; pNode = pNode.next){\n            sb.append(pNode.data);\n            // 数据元素之间使用逗号分割\n            if (pNode.next != null){\n                sb.append(\",\");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }"}],"collapsed":true,"id":"9e8f1fca2d35","title":"6.toString()"},{"parent":"aeaff4bab5ed","children":[{"parent":"edf787483590","children":[],"id":"e53772f084ed","title":"// 定义一个内部类，描述链表中的结点\n    private class Node{\n        // 存储数据\n        Object data;\n        // 存储下个结点的引用\n        Node next;\n\n        public Node() {\n        }\n\n        public Node(Object data, Node next) {\n            this.data = data;\n            this.next = next;\n        }\n    }"}],"collapsed":true,"id":"edf787483590","title":"*****private class Node"}],"collapsed":true,"id":"aeaff4bab5ed","title":"各个功能模块代码"},{"parent":"951bb2aa0763","children":[{"parent":"59b4cfbd0798","children":[],"id":"899f09bab708","title":"package pers.chenjiahao.linearity.linkstack.test;\n\nimport pers.chenjiahao.linearity.linkstack.MyLinkStack;\n\npublic class MyLinkStackTest {\n    public static void main(String[] args) {\n        // 创建链栈\n        MyLinkStack stack = new MyLinkStack();\n        System.out.println(stack.isEmpty()); // true\n        System.out.println(stack.getSize()); // 0\n        // 压栈\n        stack.push(\"ppp\");\n        stack.push(\"aaa\");\n        stack.push(\"xxx\");\n        stack.push(\"ooo\");\n        System.out.println(stack); // [ooo,xxx,aaa,ppp]\n        // 出栈\n        System.out.println(stack.pop());\n        System.out.println(stack.pop());\n        System.out.println(stack.pop());\n        System.out.println(stack.pop());\n        System.out.println(stack);\n    }\n}\n"}],"collapsed":true,"id":"59b4cfbd0798","title":"测试类"}],"collapsed":true,"id":"951bb2aa0763","title":"代码实现"}],"collapsed":false,"id":"ec030f3c33c0","title":"链式实现"},{"parent":"492fd1d10622","children":[{"parent":"32caef89bca5","children":[{"parent":"4bb6b73232b1","children":[],"id":"665d99bd458a","title":"十进制转为别的进制<br>"},{"image":{"w":391,"h":257,"url":"http://cdn.processon.com/5fdcc6d8e0b34d66b81c17f2?e=1608307944&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:CRfomUh6PbYReSklZ3YtvMOkjNg="},"parent":"4bb6b73232b1","children":[],"id":"8f42d3f88bbc","title":"图解：十进制转为二进制"},{"parent":"4bb6b73232b1","children":[{"parent":"264f28576d36","children":[],"id":"21c850569828","title":"package pers.chenjiahao.linearity.stackapplication.baseconversion;<br><br>import pers.chenjiahao.linearity.arraystack.MyArrayStack;<br><br>/**<br> * 使用栈完成进制转换<br> */<br>public class BaseConversion {<br>    public static void main(String[] args) {<br>        System.out.println(convert(100,2)); // 1100100<br>        System.out.println(convert(100,8)); // 144<br>        // 十六进制要转换到相应的abcdef<br>        // System.out.println(convert(100,16));<br>    }<br><br>    /**<br>     * 把一个十进制整数num转换decimal指定的进制<br>     * @param num      接收的十进制整数<br>     * @param decimal  指定进制<br>     * @return 返回num这个整数对应的decimal进制的字符串<br>     */<br>    public static String convert(int num,int decimal){<br>        // 保存余数<br>        MyArrayStack stack = new MyArrayStack();<br>        // 余数<br>        int remainder = num % decimal;<br>        while (num != 0 ){<br>            // 余数压栈<br>            stack.push(remainder);<br>            num = num / decimal;<br>            remainder = num % decimal;<br>        }<br>        // 出栈，余数倒序<br>        StringBuilder sb = new StringBuilder();<br>        while(!stack.isEmpty()){<br>            sb.append(stack.pop());<br>        }<br>        return sb.toString();<br>    }<br>}<br>"}],"collapsed":true,"id":"264f28576d36","title":"代码实现"}],"collapsed":false,"id":"4bb6b73232b1","title":"1.进制转换"},{"parent":"32caef89bca5","children":[{"parent":"ed43e8f25064","children":[],"id":"101912b604e8","title":"假设表达式中包含三种括号：()、[]、{}，这三种括号可以任意嵌套"},{"parent":"ed43e8f25064","children":[],"id":"43c973755a60","title":"对于任意一个左括号都需要一个对应的右括号匹配，最早出现的右括号应该与最早出现的左括号匹配"},{"parent":"ed43e8f25064","children":[{"parent":"6a0a0aeffbe4","children":[],"id":"983fe851bf0f","title":"读取整个表达式，<br>如果是左括号就直接入栈，等待与它对应的右括号出现<br>如果是右括号，则与当前栈顶的左括号判断是否匹配<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果不匹配，说明表达式不合法<br>如果是右括号，表示栈已空，表示不合法<br>读完整个表达式，堆栈不空，表示有左括号没匹配上，表达式不合法；<br>读完整个表达式，栈是空的表示所有括号都能匹配"}],"collapsed":true,"id":"6a0a0aeffbe4","title":"算法思路"},{"parent":"ed43e8f25064","children":[{"parent":"d933fe92c632","children":[],"id":"d1f0db853d34","title":"package pers.chenjiahao.linearity.stackapplication.bracketmatching;\n\nimport pers.chenjiahao.linearity.arraystack.MyArrayStack;\n\n/**\n * 检测表达式中的括号是否匹配\n */\npublic class BracketMatch {\n    public static void main(String[] args) {\n        System.out.println(bracketMath(\"([{}])\")); // true\n        System.out.println(bracketMath(\"([{{])\")); // false\n        System.out.println(bracketMath(\"([{}}])\")); // false\n    }\n\n    // 检测expression表达式中的括号是否匹配\n    public static boolean bracketMath(String expresion){\n        // 定义一个栈用来保存各种左括号\n        MyArrayStack stack = new MyArrayStack();\n        // 遍历整个表达式，如果是左括号就入栈，如果是右括号就出栈,进行判断是否匹配\n        for (int i = 0; i &lt; expresion.length(); i++) {\n            // 取出表达式的每个字符\n            char cc = expresion.charAt(i);\n            switch (cc){\n                case '(':\n                case '[':\n                case '{':\n                    stack.push(cc);// 左括号入栈\n                    break;\n                case '}':\n                    if (!stack.isEmpty() && stack.pop().equals('{')){\n                        break;\n                    }else {\n                        return false;\n                    }\n                case ']':\n                    if (!stack.isEmpty() && stack.pop().equals('[')){\n                        break;\n                    }else {\n                        return false;\n                    }\n                case ')':\n                    if (!stack.isEmpty() && stack.pop().equals('(')){\n                        break;\n                    }else {\n                        return false;\n                    }\n            }\n        }\n        // 表达式遍历完后，如果栈是空的，表示括号匹配\n        if (stack.isEmpty()){\n            return true;\n        }else {\n            return false;\n        }\n    }\n}\n"}],"collapsed":true,"id":"d933fe92c632","title":"代码实现"}],"collapsed":false,"id":"ed43e8f25064","title":"2.检测表达式中括号是否匹配<br>"},{"parent":"32caef89bca5","children":[{"parent":"835e3612e2f5","children":[{"parent":"d5d14c467ec8","children":[],"id":"bc75b5d81e23","title":"先乘除后加减"},{"parent":"d5d14c467ec8","children":[],"id":"587337cc5496","title":"先括号内，再括号外"},{"parent":"d5d14c467ec8","children":[],"id":"4aa37a9c8550","title":"从左到右进行运算"}],"collapsed":true,"id":"d5d14c467ec8","title":"四则运算的规则"},{"parent":"835e3612e2f5","children":[{"parent":"a715551323c4","children":[],"id":"df4153e7464a","title":"4+3+(6-10+2*3)*4"},{"parent":"a715551323c4","children":[],"id":"6dfc6ba6264d","title":"7+(6-10+2*3)*4"},{"parent":"a715551323c4","children":[],"id":"6f3184f2f480","title":"7+(-4+2*3)*4"},{"parent":"a715551323c4","children":[],"id":"707f818c29e3","title":"7+(-4+6)*4"},{"parent":"a715551323c4","children":[],"id":"6b4ba373fe2e","title":"7+2*4"},{"parent":"a715551323c4","children":[],"id":"8cbc22e77589","title":"7+8"},{"parent":"a715551323c4","children":[],"id":"9f437d8d99dd","title":"15"},{"parent":"a715551323c4","image":{"w":555,"h":392,"url":"http://cdn.processon.com/5fddb589e401fd5bc8367030?e=1608369049&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:FyAVCUl7k3r8WiahoAf2fR47yow="},"children":[],"id":"5ead3fd2b2b4","title":"图解"}],"collapsed":true,"id":"a715551323c4","title":"例：4+3+(6-10+2*3)*4"},{"parent":"835e3612e2f5","children":[{"parent":"e56da6c1ac15","children":[],"id":"37fd1fbc8073","title":"定义两个栈，一个存储操作符operator,一个存储操作数operand"},{"parent":"e56da6c1ac15","children":[],"id":"91d8e8cb6a91","title":"读取表达式"},{"parent":"e56da6c1ac15","children":[],"id":"c0dc1eb35ca2","title":"如果是操作数就存储到operand操作数栈中"},{"parent":"e56da6c1ac15","children":[{"parent":"a352cf1eaa71","children":[],"id":"6d30b2143842","title":"操作符栈是空，直接入栈"},{"parent":"a352cf1eaa71","children":[{"parent":"8339dbafddb5","children":[],"id":"ea8cd8249c9b","title":"当前操作符优先级高，操作符入栈"},{"parent":"8339dbafddb5","children":[],"id":"dffc86d34c87","title":"当前操作符优先级低(栈顶操作符优先级高),<br>弹出栈顶操作符，<br>再从操作数栈中弹出两个操作数做运算，<br>将运算结果存储到操作数栈中，<br>继续判断当前的操作符与栈顶操作符的优先级"}],"collapsed":true,"id":"8339dbafddb5","title":"把操作符栈中的栈顶操作符与当前操作符进行优先级比较"}],"collapsed":true,"id":"a352cf1eaa71","title":"如果是操作符"},{"parent":"e56da6c1ac15","children":[],"id":"91e21cb34821","title":"遍历完整个表达式，连个栈都不为空，依次弹出操作符栈中的操作符和操作数栈中的两个操作数进行计算，把结果再存储到操作数栈中"},{"parent":"e56da6c1ac15","children":[],"id":"d7b2a1f8de7a","title":"如果操作符栈不为空，或操作数栈中的数不止一个，则表达式错误"},{"parent":"e56da6c1ac15","children":[],"id":"34ebb22de3a9","title":"如果操作符栈为空，操作数栈中只有一个数字，返回这个数，即计算的答案"}],"collapsed":true,"id":"e56da6c1ac15","title":"算法思路"},{"parent":"835e3612e2f5","children":[{"parent":"296b6b812cee","children":[],"id":"05cb39cda802","title":"package pers.chenjiahao.linearity.stackapplication.calculateexpression;\n\nimport pers.chenjiahao.linearity.arraystack.MyArrayStack;\n\n/**\n * 使用栈来计算算数表达式的值\n */\npublic class CalculateExpression {\n    public static void main(String[] args) {\n        String expression = \"4+3+(6-10+2*3)*4\";\n        double result = calculate(expression);\n        System.out.println(result);\n    }\n\n    // 定义方法计算指定表达式的值 4+3+(6-10+2*3)*4\n    private static double calculate(String expression) {\n        // 定义一个栈用与存储操作符\n        MyArrayStack operatorStack = new MyArrayStack();\n        // 定义一个栈用与存储操作数\n        MyArrayStack operandStack = new MyArrayStack();\n        // 遍历表达式中的操作数与操作符\n        for (int i = 0; i &lt; expression.length(); i++) {\n            // 取出每个符号\n            char cc = expression.charAt(i);\n            // 如果cc是数字\n            if (Character.isDigit(cc)){\n                // 取出操作数\n                StringBuilder sb = new StringBuilder();\n                // 只要是数字就是操作数的一部分 如果这里直接取出cc的话会有问题，比如说66+55 只会取走一个6  66被分割了，所以要处理一下\n                while (Character.isDigit(cc)){\n                    sb.append(cc);\n                    i++;\n                    // 判断i++是否越界\n                    if (i &gt;= expression.length()){\n                        // 说明表达式结束了\n                        break;\n                    }\n                    // 如果没有到末尾，取出下一个字符\n                    cc = expression.charAt(i);\n                }\n                // 操作数入栈\n                operandStack.push(sb.toString());\n                // 修正一下i，i在while中最后判断了一次，需要退回一次\n                i--;\n                // 测试一下 System.out.println(sb);\n            }else {\n                // 如果是操作符\n                // 栈为空，直接将操作符入栈\n                if (operatorStack.isEmpty()){\n                    operatorStack.push(cc);\n                    continue;\n                }\n                // 操作符栈不为空,取出栈顶的操作符\n                // 栈不为空的时候需要一直判断\n                while (!operatorStack.isEmpty()){\n                    char op1 = (char) operatorStack.peek();\n                    // 判断栈中操作符与当前操作符的优先级\n                    if (compareOperator(op1,cc) &lt; 0){\n                        // 当前运算符的优先级高于栈顶运算符的优先级 直接入栈\n                        operatorStack.push(cc);\n                        break;\n                    }else if (compareOperator(op1,cc) == 0){\n                        // 当前操作符的优先级等于栈顶运算符的优先级,只有一种情况：左一半小括号遇到右一半小括号的情况\n                        // 栈中左一半小括号出栈\n                        operatorStack.pop();\n                        break;\n                    }else {\n                        // 栈顶操作符优先级高\n                        // 取出两个操作数\n                        // 如果操作数栈为空，也表示表达式错误\n                        if (operandStack.isEmpty()){\n                            throw new RuntimeException(\"表达式错误\");\n                        }\n                        double num1 = Double.parseDouble(operandStack.pop().toString());\n                        // 如果操作数栈为空，也表示表达式错误\n                        if (operandStack.isEmpty()){\n                            throw new RuntimeException(\"表达式错误\");\n                        }\n                        double num2 = Double.parseDouble(operandStack.pop().toString());\n                        // 取出栈顶操作符\n                        char operator = (char) operatorStack.pop();\n                        // 计算 num2 operator num1\n                        double result = compute(num2,operator,num1);\n                        // 把结果存储到操作数栈中\n                        operandStack.push(result);\n                        // 如果当前操作符栈为空，新的操作符应该入栈\n                        if (operatorStack.isEmpty()){\n                            operatorStack.push(cc);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // 当表达式遍历完后，如果操作符栈不为空，需要继续计算\n        while (!operatorStack.isEmpty()){\n            // 取出一个操作符\n            char operator = (char) operatorStack.pop();\n            // 取出两个操作数\n            // 如果操作数栈为空，也表示表达式错误\n            if (operandStack.isEmpty()){\n                throw new RuntimeException(\"表达式错误\");\n            }\n            double num1 = Double.parseDouble(operandStack.pop().toString());\n            // 如果操作数栈为空，也表示表达式错误\n            if (operandStack.isEmpty()){\n                throw new RuntimeException(\"表达式错误\");\n            }\n            double num2 = Double.parseDouble(operandStack.pop().toString());\n            // 计算\n            double result = compute(num2,operator,num1);\n            // 操作数入栈\n            operandStack.push(result);\n        }\n        // 能走到这里说明操作符栈已经为空了，如果操作数栈中多余一个数，说明表达式错误\n        if (operandStack.getSize() &gt; 1){\n            throw new RuntimeException(\"表达式错误\");\n        }\n        return Double.parseDouble(operandStack.pop().toString());\n    }\n\n    /**\n     * 计算num1 operator num2 表达式的值\n     * @param num2 先入栈的操作数\n     * @param operator 操作符\n     * @param num1 后入栈的操作数\n     * @return num1 operator num2 的结果\n     */\n    private static double compute(double num2, char operator, double num1) {\n        switch (operator){\n            case '+':\n                return num2 + num1;\n            case '-':\n                return num2 - num1;\n            case '*':\n                return num2 * num1;\n            case '/':\n                return num2 / num1;\n        }\n        return 0;\n    }\n\n    /**\n     * 判断两个操作符的优先级\n     * @param op1 栈顶中的操作符\n     * @param op2 从表达式中取出的操作符\n     * @return 如果op1优先级高 返回整数，如果op2优先级高 返回负数\n     */\n    private static int compareOperator(char op1, char op2) {\n        // 第一个操作符是+- 第二个操作符是*/(\n        if (op1 == '+' || op1 == '-'){\n            if (op2 == '*' || op2 == '/' || op2 == '('){\n                // 能走都这里说明 op1 优先级低\n                return -1;\n            }\n        }\n        // 第一个操作符是* / 第二个操作符是(\n        if (op1 == '*' || op1 == '/'){\n            if (op2 == '('){\n                return -1;\n            }\n        }\n        if (op1 == '('){\n            if (op2 == ')'){\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n        return 1;\n    }\n}\n"}],"collapsed":true,"id":"296b6b812cee","title":"代码实现"}],"collapsed":false,"id":"835e3612e2f5","title":"3.算术表达式的求值"}],"collapsed":false,"id":"32caef89bca5","title":"栈的应用"}],"collapsed":false,"id":"492fd1d10622","title":"栈"},{"parent":"cec51a1841f6","children":[{"parent":"2984462df776","children":[{"parent":"fa1fefa5a9fb","children":[],"id":"468c5e7ddef7","title":"队列(Queue)简称为队，也是一种受限的线性表"},{"parent":"fa1fefa5a9fb","children":[],"id":"9140360cf70e","title":"只允许在线性表的一段进行插入，在另一端进行删除"},{"parent":"fa1fefa5a9fb","children":[],"id":"01b8bfc7c117","title":"插入数据的一端称为队尾(rear)"},{"parent":"fa1fefa5a9fb","children":[],"id":"696354a6d4c1","title":"删除数据的一段称为队首(front)"},{"parent":"fa1fefa5a9fb","children":[],"id":"540685f65add","title":"向队列添加数据称为入队/进队，新入队的元素称为队尾元素"},{"parent":"fa1fefa5a9fb","children":[],"id":"944485627da5","title":"从队列中删除元素称为出队或离队，元素出队之后，它的后续元素称为新的队首元素"},{"parent":"fa1fefa5a9fb","children":[],"id":"cee708b7b288","title":"队列是先进先出的(FIFO)"}],"collapsed":false,"id":"fa1fefa5a9fb","title":"基本概念"},{"parent":"2984462df776","children":[{"parent":"0092388f6bdd","children":[],"id":"b05c475e60c1","title":"ADT Queue{<br>&nbsp; &nbsp; &nbsp; &nbsp;数据对象：D = {a0,a1,a2...an,ai是同一种数据类型的元素}<br>&nbsp; &nbsp; &nbsp; &nbsp;数据关系：R = {&lt;ai,a(i+1)&gt;}<br>&nbsp; &nbsp; &nbsp; &nbsp;基本操作：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getSize() 返回元素的个数<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isEmpty()判断队列是否为空<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; enQueue(Object e) 入队<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deQueue() 出队<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peek() 返回队首的元素<br>}"}],"collapsed":false,"id":"0092388f6bdd","title":"队列抽象数据类型"},{"parent":"2984462df776","children":[{"parent":"d893241b9cd1","children":[],"id":"7f44d5ecbde8","title":"package pers.chenjiahao.linearity.queueoperator;\n\npublic interface MyQueue {\n    int getSize(); // 返回元素的个数\n    boolean isEmpty();// 判断队列是否为空\n    void enQueue(Object e); // 入队\n    Object deQueue(); //  出队\n    Object peek();// 返回队首元素\n}\n"}],"collapsed":true,"id":"d893241b9cd1","title":"MyQueue接口"},{"parent":"2984462df776","children":[{"parent":"5bac3170dc95","children":[{"parent":"13180aa94b4f","children":[],"id":"f2289ac239b8","title":"在队列的实现中，可以把数据设想为一个圆环，这种数组称为循环数组，用循环数组实现的队列称为循环队列"},{"parent":"13180aa94b4f","children":[],"id":"982489d448e2","title":"用front指针指向队首元素所在的单元，使用rear指针指向队尾元素所在单元的后一个单元"},{"parent":"13180aa94b4f","children":[],"id":"d761b7a3e32a","title":"在元素入队时，将心如对的元素保存到rear指向的单元，然后rear指针后移"},{"parent":"13180aa94b4f","children":[],"id":"46975ff35053","title":"在元素出队时，将队首指针front指向的元素返回，然后front后移"},{"image":{"w":212,"h":181,"url":"http://cdn.processon.com/5fdddbd0e401fd5bc836b432?e=1608378848&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:iKGUbilPMcWe4tsItKs80YA05z0="},"parent":"13180aa94b4f","children":[],"id":"9d544ec55f47","title":"图解"}],"collapsed":true,"id":"13180aa94b4f","title":"基本概念"},{"parent":"5bac3170dc95","children":[{"image":{"w":471,"h":208,"url":"http://cdn.processon.com/5fdddc5c1e085304fb8c9310?e=1608378989&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:NQ1CTjjfesX4aMUk4gHgfkcayBY="},"parent":"8ec79faaefca","children":[],"id":"4d140040d09a","title":"图解"},{"parent":"8ec79faaefca","children":[{"parent":"a9083535dd4e","children":[],"id":"80ec9e5fa172","title":"少用一个存储单元，当队尾指针rear的下一个单元是队首指针front时，停止入队"},{"parent":"a9083535dd4e","children":[],"id":"9f41ac160903","title":"(rear+1)%capacity==front时表示队列已满"},{"parent":"a9083535dd4e","children":[],"id":"cc719077b6fd","title":"front==rear时表示队列为空"},{"image":{"w":309,"h":227,"url":"http://cdn.processon.com/5fdddd58e0b34d66b823d492?e=1608379240&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:SQoh38UlJnWbFgjFG4deD_x7XWM="},"parent":"a9083535dd4e","children":[],"id":"b775c3e0aadb","title":"图解：表示队列已满"}],"collapsed":true,"id":"a9083535dd4e","title":"第一种方式"},{"parent":"8ec79faaefca","children":[{"parent":"cc79357aa704","children":[],"id":"4bf375952c73","title":"增设一个变量表示队列为空还是满，通常使用size变量表示元素的个数"},{"parent":"cc79357aa704","children":[],"id":"15da114543dc","title":"当size==0时队列为空"},{"parent":"cc79357aa704","children":[],"id":"ebf7a447bcc8","title":"当size==capacity时表示队列已满"}],"collapsed":true,"id":"cc79357aa704","title":"第二种方式"}],"collapsed":true,"id":"8ec79faaefca","title":"队列为空和队列已满的表示"},{"parent":"5bac3170dc95","children":[{"parent":"0e3dd4d541fc","children":[],"id":"191648a600fe","title":"创建一个MyArrayQueue类，实现MyQueue接口"},{"parent":"0e3dd4d541fc","children":[{"parent":"3553343d8c7c","children":[],"id":"aa6ce7488963","title":"package pers.chenjiahao.linearity.arrayqueue;\n\nimport pers.chenjiahao.linearity.queueoperator.MyQueue;\nimport pers.chenjiahao.linearity.queueoperator.exception.QueueEmptyException;\n\n/**\n * 队列的顺序存储实现\n */\npublic class MyArrayQueue implements MyQueue {\n    // 定义数组存储队列中的元素\n    private Object[] elements;\n    // 设置初始化容量的默认值\n    private static final int DEFAULT_CAPACITY = 8;\n    // 队首\n    private int front;\n    // 队尾\n    private int rear;\n    // 元素的个数\n    private int size;\n\n    // 无参构造\n    public MyArrayQueue() {\n        elements = new Object[DEFAULT_CAPACITY];\n    }\n\n    // 指定初始化容量的构造\n    public MyArrayQueue(int initialCapacity) {\n        elements = new Object[initialCapacity];\n    }\n\n    // 返回元素的个数\n    public int getSize(){\n        return size;\n    }\n\n    // 判断队列是否为空\n    public boolean isEmpty(){\n        return size == 0;\n    }\n\n    // 入队\n    public void enQueue(Object e){\n        // 如果队列已满，可以对数组扩容\n        if (size &gt;= elements.length){\n            expandQueue();\n        }\n        // 把元素存储到rear指针指向的单元\n        elements[rear] = e;\n        // rear指针后移\n        rear = (rear + 1) % elements.length;\n        // 元素加一\n        size++;\n    }\n\n    //  出队\n    public Object deQueue(){\n        // 如果队列为空\n        if (size &lt;= 0){\n            // 抛出队列为空异常\n            throw new QueueEmptyException(\"队列为空\");\n        }\n        // 队列不为空，把front指向的元素返回\n        Object old = elements[front];\n        // 将front指针后移\n        front = (front + 1) % elements.length;\n        // 元素个数-1\n        return old;\n    }\n\n    // 返回队首元素\n    public Object peek(){\n        // 队列为空，抛出异常\n        if (size &lt;= 0){\n            // 抛出队列为空异常\n            throw new QueueEmptyException(\"队列为空\");\n        }\n        return elements[front];\n    }\n\n    // 队列的数组进行扩容\n    private void expandQueue() {\n        // 定义一个更大的数组\n        Object[] newElements = new Object[elements.length * 2];\n        // 把原来的数组的内容赋值到新的数组中,这里需要注意，在旧的数组中，队首不一定是从0开始的\n        // 需要将旧数组放到新数组的0下标开始\n        for (int i = 0; i &lt; size; i++) {\n            newElements[i] = elements[front];\n            front = (front + 1) % elements.length;\n        }\n        // 让原来的数组名，指向新的数组\n        elements = newElements;\n        // 调整新的队首和队尾指针\n        front = 0;\n        rear = size;\n    }\n}\n"}],"collapsed":true,"id":"3553343d8c7c","title":"完整代码"},{"parent":"0e3dd4d541fc","children":[{"parent":"fcf8c11e7ab5","children":[{"parent":"d8c35a738933","children":[],"id":"0cd1bb84d84a","title":"// 返回元素的个数\n    public int getSize(){\n        return size;\n    }"}],"collapsed":true,"id":"d8c35a738933","title":"1.getSize()"},{"parent":"fcf8c11e7ab5","children":[{"parent":"2ef20128007a","children":[],"id":"27a538d27505","title":"// 判断队列是否为空\n    public boolean isEmpty(){\n        return size == 0;\n    }"}],"collapsed":true,"id":"2ef20128007a","title":"2.isEmpty()"},{"parent":"fcf8c11e7ab5","children":[{"parent":"aa56a1ba011e","children":[],"id":"11c9841764cd","title":"// 入队\n    public void enQueue(Object e){\n        // 如果队列已满，可以对数组扩容\n        if (size &gt;= elements.length){\n            expandQueue();\n        }\n        // 把元素存储到rear指针指向的单元\n        elements[rear] = e;\n        // rear指针后移\n        rear = (rear + 1) % elements.length;\n        // 元素加一\n        size++;\n    }"}],"collapsed":true,"id":"aa56a1ba011e","title":"3.enQueue(Object e)"},{"parent":"fcf8c11e7ab5","children":[{"parent":"8ff74905476b","children":[],"id":"49027754887a","title":"//  出队\n    public Object deQueue(){\n        // 如果队列为空\n        if (size &lt;= 0){\n            // 抛出队列为空异常\n            throw new QueueEmptyException(\"队列为空\");\n        }\n        // 队列不为空，把front指向的元素返回\n        Object old = elements[front];\n        // 将front指针后移\n        front = (front + 1) % elements.length;\n        // 元素个数-1\n        return old;\n    }"}],"collapsed":true,"id":"8ff74905476b","title":"4.deQueue()"},{"parent":"fcf8c11e7ab5","children":[{"parent":"129168ae7345","children":[],"id":"9bcfebba83e7","title":"// 返回队首元素\n    public Object peek(){\n        // 队列为空，抛出异常\n        if (size &lt;= 0){\n            // 抛出队列为空异常\n            throw new QueueEmptyException(\"队列为空\");\n        }\n        return elements[front];\n    }"}],"collapsed":true,"id":"129168ae7345","title":"5.peek()"},{"parent":"fcf8c11e7ab5","children":[{"parent":"6250e0d355e4","children":[],"id":"c6e968593d57","title":"// 队列的数组进行扩容\n    private void expandQueue() {\n        // 定义一个更大的数组\n        Object[] newElements = new Object[elements.length * 2];\n        // 把原来的数组的内容赋值到新的数组中,这里需要注意，在旧的数组中，队首不一定是从0开始的\n        // 需要将旧数组放到新数组的0下标开始\n        for (int i = 0; i &lt; size; i++) {\n            newElements[i] = elements[front];\n            front = (front + 1) % elements.length;\n        }\n        // 让原来的数组名，指向新的数组\n        elements = newElements;\n        // 调整新的队首和队尾指针\n        front = 0;\n        rear = size;\n    }"}],"collapsed":true,"id":"6250e0d355e4","title":"private void expandQueue()"}],"collapsed":true,"id":"fcf8c11e7ab5","title":"各个功能模块代码"},{"parent":"0e3dd4d541fc","children":[{"parent":"cce1fd73e9ff","children":[],"id":"b0e2b75f3ec3","title":"package pers.chenjiahao.linearity.arrayqueue.test;\n\nimport pers.chenjiahao.linearity.arrayqueue.MyArrayQueue;\nimport pers.chenjiahao.linearity.queueoperator.MyQueue;\n\n/**\n * 测试顺序队列\n */\npublic class MyArrayQueueTest {\n    public static void main(String[] args) {\n        MyQueue queue = new MyArrayQueue();\n        // 入队\n        queue.enQueue(\"a\");\n        queue.enQueue(\"b\");\n        queue.enQueue(\"C\");\n        queue.enQueue(\"d\");\n        // 返回队首元素\n        System.out.println(queue.peek());\n        // 出队\n        System.out.println(queue.deQueue());\n        System.out.println(queue.deQueue());\n        System.out.println(queue.deQueue());\n        System.out.println(queue.deQueue());\n        // System.out.println(queue.deQueue());\n        queue.enQueue(\"1\");\n        queue.enQueue(\"2\");\n        queue.enQueue(\"3\");\n        queue.enQueue(\"4\");\n        queue.enQueue(\"5\");\n        queue.enQueue(\"6\");\n        queue.enQueue(\"7\");\n        queue.enQueue(\"8\");\n        queue.enQueue(\"J\");\n        queue.enQueue(\"Q\");\n        queue.enQueue(\"K\");\n    }\n}\n"}],"collapsed":true,"id":"cce1fd73e9ff","title":"测试类"}],"collapsed":true,"id":"0e3dd4d541fc","title":"代码实现"}],"collapsed":false,"id":"5bac3170dc95","title":"顺序实现"},{"parent":"2984462df776","children":[{"parent":"da22888367e2","children":[{"parent":"ab0f953a09c6","children":[],"id":"a133447b7d23","title":"使用单向链表来实现队列"},{"parent":"ab0f953a09c6","children":[],"id":"037cb5f2aa0a","title":"把链表的头部作为队首，把链表的尾部作为队尾"},{"parent":"ab0f953a09c6","image":{"w":480,"h":131,"url":"http://cdn.processon.com/5fddde69e0b34d66b823d5dd?e=1608379513&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:a9QJXCcvhhVVfVeMKeZgEvHzhCE="},"children":[],"id":"be2bd04fac77","title":"图解"}],"collapsed":true,"id":"ab0f953a09c6","title":"基本概念"},{"parent":"da22888367e2","children":[{"parent":"c2613e693f15","children":[],"id":"a860147288b3","title":"创建一个MyLinkQueue类，实现MyQueue接口"},{"parent":"c2613e693f15","children":[{"parent":"a2c546129d70","children":[],"id":"04274980ca26","title":"package pers.chenjiahao.linearity.linkqueue;\n\nimport pers.chenjiahao.linearity.queueoperator.MyQueue;\nimport pers.chenjiahao.linearity.queueoperator.exception.QueueEmptyException;\n\n/**\n * 队列的链式存储\n */\npublic class MyLinkQueue implements MyQueue {\n    // 队首\n    private Node front;\n    // 队尾\n    private Node rear;\n    // 元素的个数\n    private int size;\n\n    // 返回元素的个数\n    @Override\n    public int getSize() {\n        return size;\n    }\n\n    // 判断队列是否为空\n    @Override\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    // 入队\n    @Override\n    public void enQueue(Object e) {\n        // 生成一个结点\n        Node newNode = new Node(e,null);\n        // 把结点连接到队列中\n        if (rear == null){\n            // 这是添加的第一个元素，既是头结点也是尾结点\n            rear = newNode;\n            front = newNode;\n        }else {\n            // 把结点连接到队列的尾部\n            rear.next = newNode;\n            // rear 指针指向新添加的元素\n            rear = newNode;\n        }\n        // 元素个数+1\n        size++;\n    }\n\n    // 出队\n    @Override\n    public Object deQueue() {\n        // 判断队列是否为空\n        if (size &lt;= 0){\n            throw new QueueEmptyException(\"队列为空\");\n        }\n        // 保存要出队的数据\n        Object old = front.element;\n        // 指针下移\n        front = front.next;\n        // 如果出队后队列为空，调整尾指针\n        if (front == null){\n            rear = null;\n        }\n        // 元素-1\n        size--;\n        return old;\n    }\n\n    // 返回队首元素\n    @Override\n    public Object peek() {\n        // 判断队列是否为空\n        if (size &lt;= 0){\n            throw new QueueEmptyException(\"队列为空\");\n        }\n        return front.element;\n    }\n\n    // 内部类表示单向链表的结点\n    private class Node{\n        Object element;\n        Node next;\n        public Node(Object element, Node next) {\n            this.element = element;\n            this.next = next;\n        }\n    }\n}\n"}],"collapsed":true,"id":"a2c546129d70","title":"完整代码"},{"parent":"c2613e693f15","children":[{"parent":"70811ec3703e","children":[{"parent":"07786cefe958","children":[],"id":"bc6081a969f4","title":"// 返回元素的个数\n    @Override\n    public int getSize() {\n        return size;\n    }"}],"collapsed":true,"id":"07786cefe958","title":"1.getSize()"},{"parent":"70811ec3703e","children":[{"parent":"83742ee49c65","children":[],"id":"38eedc717434","title":"// 判断队列是否为空\n    @Override\n    public boolean isEmpty() {\n        return size == 0;\n    }"}],"collapsed":true,"id":"83742ee49c65","title":"2.isEmpty()"},{"parent":"70811ec3703e","children":[{"parent":"c30795132d0b","children":[],"id":"d9cafc7bb3aa","title":"// 入队\n    @Override\n    public void enQueue(Object e) {\n        // 生成一个结点\n        Node newNode = new Node(e,null);\n        // 把结点连接到队列中\n        if (rear == null){\n            // 这是添加的第一个元素，既是头结点也是尾结点\n            rear = newNode;\n            front = newNode;\n        }else {\n            // 把结点连接到队列的尾部\n            rear.next = newNode;\n            // rear 指针指向新添加的元素\n            rear = newNode;\n        }\n        // 元素个数+1\n        size++;\n    }"}],"collapsed":true,"id":"c30795132d0b","title":"3.enQueue(Object e)"},{"parent":"70811ec3703e","children":[{"parent":"06079408fba5","children":[],"id":"bf082cd210f7","title":"// 出队\n    @Override\n    public Object deQueue() {\n        // 判断队列是否为空\n        if (size &lt;= 0){\n            throw new QueueEmptyException(\"队列为空\");\n        }\n        // 保存要出队的数据\n        Object old = front.element;\n        // 指针下移\n        front = front.next;\n        // 如果出队后队列为空，调整尾指针\n        if (front == null){\n            rear = null;\n        }\n        // 元素-1\n        size--;\n        return old;\n    }"}],"collapsed":true,"id":"06079408fba5","title":"4.deQueue()"},{"parent":"70811ec3703e","children":[{"parent":"c0d14f0acf51","children":[],"id":"ca20816d3d44","title":"// 返回队首元素\n    @Override\n    public Object peek() {\n        // 判断队列是否为空\n        if (size &lt;= 0){\n            throw new QueueEmptyException(\"队列为空\");\n        }\n        return front.element;\n    }"}],"collapsed":true,"id":"c0d14f0acf51","title":"5.peek()"},{"parent":"70811ec3703e","children":[{"parent":"5f1e269463c4","children":[],"id":"3416c7b5c0ae","title":"// 内部类表示单向链表的结点\n    private class Node{\n        Object element;\n        Node next;\n        public Node(Object element, Node next) {\n            this.element = element;\n            this.next = next;\n        }\n    }"}],"collapsed":true,"id":"5f1e269463c4","title":"private class Node"}],"collapsed":true,"id":"70811ec3703e","title":"各个功能模块代码"},{"parent":"c2613e693f15","children":[{"parent":"f082a4939b6e","children":[],"id":"21dd98e34b57","title":"package pers.chenjiahao.linearity.linkqueue.test;\n\nimport pers.chenjiahao.linearity.linkqueue.MyLinkQueue;\nimport pers.chenjiahao.linearity.queueoperator.MyQueue;\n\npublic class MyLinkQueueTest {\n    public static void main(String[] args) {\n        MyQueue queue = new MyLinkQueue();\n        System.out.println(queue.getSize());\n        System.out.println(queue.isEmpty());\n        queue.enQueue(\"a\");\n        queue.enQueue(\"b\");\n        queue.enQueue(\"c\");\n        System.out.println(queue.getSize());\n        System.out.println(queue.getSize());\n        System.out.println(queue.peek());\n        queue.deQueue();\n        System.out.println(queue.getSize());\n        System.out.println(queue.isEmpty());\n    }\n}\n"}],"collapsed":true,"id":"f082a4939b6e","title":"测试类"}],"collapsed":true,"id":"c2613e693f15","title":"代码实现<br>"}],"collapsed":false,"id":"da22888367e2","title":"链式实现"}],"collapsed":false,"id":"2984462df776","title":"队列"}],"collapsed":true,"id":"cec51a1841f6","title":"4.栈与队列"},{"parent":"270b57d67f7f","children":[{"parent":"dec8bf74a208","children":[{"parent":"46a473e1d9dc","children":[],"id":"036cd1177c46","title":"树是由一个集合及该集合上的定义的一种关系构成的。集合中的元素称为树的结点，定义的关系称为父子关系，父子关系的树的结点之间建立一个层次结构。"},{"parent":"46a473e1d9dc","children":[],"id":"3e13e73accec","title":"树的递归定义：<br>&nbsp; &nbsp; &nbsp; 树是由n(n&gt;=0)个结点组成的有限集<br>&nbsp; &nbsp; &nbsp; 当n=0时，称为空树；<br>&nbsp; &nbsp; &nbsp; 当n&gt;0时，就是一颗非空树:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （1）有且仅有一个特定的称为根的结点（root）;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （2）当n&gt;1时，其他结点可以分为m(m&gt;0)个互不相交的有限集T1，T2...，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;其中每个有限集又是一颗树，称为根节点的子树(SubTree)"},{"image":{"w":502,"h":227,"url":"http://cdn.processon.com/5ff19f356376896cfa0097a1?e=1609674053&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:64Qsg9varpZGksQjr-uIPk7pVqk="},"parent":"46a473e1d9dc","children":[],"id":"fe0431735e8a","title":"在右图中，结点A是根节点，它包含T1和T2两棵树，T1={BDGHI},T2={CEFJ},每颗子树又是一颗树，<br>在T1子树中，B是根节点，在T2子树中，C是根节点"},{"parent":"46a473e1d9dc","children":[],"id":"978acec8e7dd","title":"当n&gt;0时，在非空树中，根节点是唯一的<br>当m&gt;0时，某个结点的子树是没有限制的，并且各个子树肯定是不相交的"}],"collapsed":false,"id":"46a473e1d9dc","title":"树的定义"},{"parent":"dec8bf74a208","children":[{"parent":"928c1ee83702","children":[],"id":"ce69eca28b71","title":"结点拥有的子树的数量称为结点的度(Degree)"},{"parent":"928c1ee83702","children":[],"id":"6f679a850f04","title":"度为0的结点称为叶子结点(Leaf)或终端结点，度不为0的结点称为分支结点或非终端结点<br>"},{"parent":"928c1ee83702","children":[],"id":"6842f437af65","title":"除了根结点外，分支结点也称为内部节点"},{"parent":"928c1ee83702","children":[],"id":"868a06fba76a","title":"树的度是树内各个结点中度的最大值"},{"image":{"w":523,"h":237,"url":"http://cdn.processon.com/5ff2f7c96376896cfa1f3f3b?e=1609762265&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:b0nrlP3oaDGhREI_iuE6bz35P5M="},"parent":"928c1ee83702","children":[],"id":"f2f9e8b5e4b2","title":""},{"parent":"928c1ee83702","children":[],"id":"6064ce61d92e","title":"结点的子树的根称为该结点的孩子(Child)，相应的该结点称为孩子结点的双亲(Parent)结点或父结点<br>"},{"parent":"928c1ee83702","children":[],"id":"d20aae56cb1e","title":"父子结点之间的连线是树的一条边，树种结点数等于树的边数+1（结点数=边数+1）"},{"parent":"928c1ee83702","children":[],"id":"6947ccb6ff49","title":"在树中，根结点没有双亲结点，其他结点都有并且只有一个父结点，每个结点可以有多个孩子结点<br>"},{"parent":"928c1ee83702","children":[],"id":"ca222af68917","title":"同一个双亲的孩子之间互称为兄弟(Sibling)"},{"parent":"928c1ee83702","children":[],"id":"dbfce6aa2214","title":"结点的祖先是从根结点到该结点所经过的分支上的所有的结点"},{"parent":"928c1ee83702","children":[],"id":"6615470ad9dd","title":"以某结点为根的子树上的任一结点都称为该结点的子孙"},{"image":{"w":523,"h":176,"url":"http://cdn.processon.com/5ff2f8ff07912977be1b5c9a?e=1609762576&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Jjt5VWv-ECTLH0IeJIhr9SLIrH4="},"parent":"928c1ee83702","children":[],"id":"4d972d74aa6c","title":""},{"parent":"928c1ee83702","children":[],"id":"6ab70b98f493","title":"结点的层次(Level)是从根结点开始，根为第一层，根的孩子为第二层，以此类推，<br>注意：有人把层次的定义是从0开始的，即根为第0层<br>"},{"parent":"928c1ee83702","children":[],"id":"c7f1ded6a6bc","title":"如果根结点在第i层，则其子树的根就在i+1层"},{"image":{"w":506,"h":269,"url":"http://cdn.processon.com/5ff2fa1fe0b34d19e41b0768?e=1609762863&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:HGz8fgLSqmf3Yk7OLKozKj2tyuQ="},"parent":"928c1ee83702","children":[],"id":"b3a5f9b695e5","title":""},{"parent":"928c1ee83702","children":[],"id":"2ba376f41d9b","title":"双亲结点（父结点）在同一个层次上的结点互为堂兄弟，即DEF互为堂兄弟"},{"parent":"928c1ee83702","children":[],"id":"e01795c6c475","title":"树中结点的最大层次称为树的深度(Depth)或高度，当前树的高度是4"},{"parent":"928c1ee83702","children":[],"id":"e5c4cf24c807","title":"在树中k+1个结点通过k条边构成的序列称为长度为k的路径，在途中{(D,B),(B,A),(A,C),(C,E)}构成<br>了一条连接D结点与E结点的路径，该路径的长度为4，在树中任意两个结点都有唯一的路径，<br>从根节点开始，存在到其他任意结点的唯一路径"},{"parent":"928c1ee83702","children":[],"id":"a2d43a16439d","title":"如果将树的结点的各个子树看作是从左到右有顺序的，不能互换的，则称该树为有序树，<br>否则为无序树，如果不特殊说明，一般讨论的是有序树"},{"parent":"928c1ee83702","children":[],"id":"25b4a0493807","title":"树中所有结点最大度数为m的有序树称为m叉树"},{"parent":"928c1ee83702","children":[],"id":"0250d5024fb5","title":"森林(Forest)是m(m&gt;=0)棵互不相交的集合，对树的每个结点而言，其子树的集合就是森林，<br>删去树的根就得到一个森林，反之，把森林加一个树的根就变成一棵树"}],"collapsed":false,"id":"928c1ee83702","title":"相关概念"},{"parent":"dec8bf74a208","children":[{"parent":"6131aecffc16","children":[],"id":"a05d840f379a","title":"ADT Tree{<br>&nbsp; &nbsp; &nbsp; 数据对象 D：D是具有相同性质的数据元素的集合<br>&nbsp; &nbsp; &nbsp; 数据关系 R：如果D是空则R是空；<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果D不是空，D中存在唯一一个称为根的元素root，该元素没有前驱；<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 除了根元素外，D中每个元素都有且只有一个前驱<br>&nbsp; &nbsp; &nbsp; 数据操作：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getSize():返回元素的个数<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getRoot():返回树的根元素<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getParent(x):返回x结点的父结点<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getFirstChild(x):返回x结点的第一个孩子<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getNextSibling(x):返回x结点的下一个兄弟结点，如果x是最后一个孩子，返回null<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getHeight(x):返回以x为根的树的高度<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;insertChild(x,child):将结点child为根的子树插入到当前树中，作为x结点的孩子<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;deleteChild(x,i):删除结点x的第i棵子树<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;preOrder(x):前序遍历x为根的树<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inOrder(x):中序遍历x为根的树<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;postOrder(x):后序遍历x为根的树<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;levelOrder(x):按层次遍历x为根的树<br>}<br>"}],"collapsed":true,"id":"6131aecffc16","title":"树的抽象数据类型"},{"parent":"dec8bf74a208","children":[{"parent":"a994aa88d855","children":[{"parent":"6989b7772412","children":[{"parent":"0493d7593d4e","children":[],"id":"43f68bc90c4f","title":"树中的结点，除了根节点外，都有且只有一个双亲结点，可以使用数组存储树种的每个结点，<br>数组的下标就是数组的位置指针，每个结点再增加一个指向双亲的指针域，结点的结构可以定义为下图"},{"image":{"w":286,"h":105,"url":"http://cdn.processon.com/5ff2fe61e0b34d19e41dcb9f?e=1609763953&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:juqLDsKice-JxmlJxm5Vw0QfT94="},"parent":"0493d7593d4e","children":[],"id":"35c319f0834c","title":"<br>"},{"image":{"w":442,"h":268,"url":"http://cdn.processon.com/5ff2fea0f346fb432bd6aaab?e=1609764017&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TIvPp97B9Dfev4DtX9oKSufFUDQ="},"parent":"0493d7593d4e","children":[],"id":"9a4da22e9f4d","title":"使用该方式存储这个树"},{"image":{"w":218,"h":269,"url":"http://cdn.processon.com/5ff2fec3f346fb432bd6ab0d?e=1609764051&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:FAQYB1wLwHjnxpe9d_x9ICSMErI="},"parent":"0493d7593d4e","children":[],"id":"58a88f1d34d6","title":"存储结构为上图"},{"parent":"0493d7593d4e","children":[],"id":"8eda4f25bc4d","title":"在双亲表示法存储结构中，可以方便的通过parent指针域找到该结点的父结点，<br>"},{"parent":"0493d7593d4e","children":[],"id":"297378bfb2e8","title":"缺点：如果要找某个结点的孩子结点，需要遍历整个数组"}],"collapsed":true,"id":"0493d7593d4e","title":"第一种方式"},{"parent":"6989b7772412","children":[{"parent":"121be8ef96df","children":[],"id":"880963185e46","title":"可以在结点中再增加一个长子域，指向第一个孩子的指针域，如果没有孩子，这个章子域设置为-1"},{"image":{"w":433,"h":209,"url":"http://cdn.processon.com/5ff300745653bb21c1b9b0f4?e=1609764484&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:1JxrpL9AjxRdHFoPCw_k0WQMnM4="},"parent":"121be8ef96df","children":[],"id":"96dd4a22a09f","title":"<br>"}],"collapsed":true,"id":"121be8ef96df","title":"第二种方式"}],"collapsed":false,"id":"6989b7772412","title":"双亲表示法"},{"parent":"a994aa88d855","children":[{"parent":"53a28548324d","children":[],"id":"20dc8e83cea1","title":"树中每个结点都可能有多颗子树，可以考虑使用多重链表，每个结点可以有多个指针域，<br>每个指针域指向它的子树的根节点，把这种方法称为多重链表表示法"},{"parent":"53a28548324d","children":[],"id":"6828be1823d1","title":"树的每个结点的度可能不一样，即每个结点的孩子个数可能不相等，一般有两种设计方案"},{"parent":"53a28548324d","children":[{"parent":"65ef9a53ac13","children":[],"id":"745201406ebc","title":"结点中指针域的个数就是树的度(树中结点最多的孩子树)"},{"parent":"65ef9a53ac13","image":{"w":333,"h":25,"url":"http://cdn.processon.com/5ff301667d9c0863d308e02e?e=1609764726&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:gyUlWYLksGYRq2ry5Yp9unpA7r4="},"children":[],"id":"1c3a6ffd7a13","title":"结点中孩子域的个数就是树的度"},{"image":{"w":300,"h":226,"url":"http://cdn.processon.com/5ff301c307912977be262150?e=1609764819&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0QXtOnAnKWmNwPcEEAFLGMx0vRQ="},"parent":"65ef9a53ac13","children":[],"id":"60eb0bc84886","title":"存储该树"},{"image":{"w":533,"h":199,"url":"http://cdn.processon.com/5ff301fa5653bb21c1b9ba30?e=1609764874&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:fEUgX7xK-I04zLjWV8jNrbwhhaY="},"parent":"65ef9a53ac13","children":[],"id":"134bc1888082","title":"上图中的树使用孩子表示法可以表示为如图"},{"parent":"65ef9a53ac13","children":[],"id":"3da2f34e9b5c","title":"缺点：如果树中各个结点的度相差很大时，很浪费空间，有很多结点的指针域是空的，<br>这种表示方法适合树的各个结点的度相差很小的情况"}],"collapsed":true,"id":"65ef9a53ac13","title":"方案一"},{"parent":"53a28548324d","children":[{"parent":"ae5606ff6e10","children":[],"id":"afbb63d92e3b","title":"每个结点的指针域的个数等于该结点的度，在结点中专门定义一个存储该结点度的域"},{"image":{"w":509,"h":41,"url":"http://cdn.processon.com/5ff3028607912977be270c6e?e=1609765014&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:-DVNpI-AKVTgGFGy6zbv4gxr7bE="},"parent":"ae5606ff6e10","children":[],"id":"bd7bb23c5229","title":"结点可以设计为如图"},{"image":{"w":300,"h":226,"url":"http://cdn.processon.com/5ff301c307912977be262150?e=1609764819&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0QXtOnAnKWmNwPcEEAFLGMx0vRQ="},"parent":"ae5606ff6e10","children":[],"id":"e5e35f785a59","title":"存储该树"},{"image":{"w":508,"h":275,"url":"http://cdn.processon.com/5ff302bd6376896cfa25cd99?e=1609765069&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:fEVUaHXdmYKog91Q48MjGiLGBJw="},"parent":"ae5606ff6e10","children":[],"id":"f57605f1af03","title":"上图的树可以表示为如图"},{"parent":"ae5606ff6e10","children":[],"id":"98cfdab5f812","title":"这种方法提高了空间的利用率"},{"parent":"ae5606ff6e10","children":[],"id":"8cec6081bc22","title":"缺点：各个结点的结构可能不一样，还要维护结点的度的值，会增加时间上的损耗"},{"parent":"ae5606ff6e10","children":[{"parent":"1997cdaf64e0","children":[],"id":"8d1e3a45b089","title":"可以定义一个线性表存储树种的所有结点的信息，称为结点表，每个结点建立一个孩子表，<br>孩子表只存储孩子结点在数组中的存储位置，由于每个结点的孩子结点的个数是不确定的，<br>经常使用一个链表表示孩子之间的关系，这就是孩子表示法"},{"image":{"w":466,"h":274,"url":"http://cdn.processon.com/5ff3037d7d9c0863d308e681?e=1609765261&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Krt5EsbaY3w_O901UpGLtjdvHMI="},"parent":"1997cdaf64e0","children":[],"id":"4c79161d145c","title":""},{"parent":"1997cdaf64e0","children":[{"parent":"f09d70a88b1b","image":{"w":152,"h":45,"url":"http://cdn.processon.com/5ff303dee401fd661a110d1b?e=1609765358&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:7GxOJ2aXUa0XL6WZe6sJY_3AzJM="},"children":[],"id":"8fead8ff819e","title":""}],"collapsed":true,"id":"f09d70a88b1b","title":"在这种表示法中需要设计两种结点，一个结点表数组中表头结点，包括数据域和指向第一个孩子的指针域"},{"parent":"1997cdaf64e0","children":[{"parent":"155760e5c277","image":{"w":130,"h":39,"url":"http://cdn.processon.com/5ff3040e7d9c0863d308e836?e=1609765406&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:DYryPuHoiynGQZyEYov5fjqijf8="},"children":[],"id":"5766ade7e2b7","title":""}],"collapsed":true,"id":"155760e5c277","title":"还需要设计一个孩子结点，存储孩子结点的数组的下标和指向下个孩子的指针"},{"parent":"1997cdaf64e0","children":[],"id":"b5a8ca71f803","title":"在这种结构中，可以方便查找某个结点的孩子，也可以方便查找某个结点的兄弟，只需要访问这个结点的孩子链表即可，<br>如果需要查找结点的父结点，还需要遍历整棵树，可以在结点表中，即数组中的结点增加一个指向父结点的指针，<br>如下图所示"}],"id":"1997cdaf64e0","title":"方案三（双亲孩子表示法）"}],"collapsed":true,"id":"ae5606ff6e10","title":"方案二"}],"collapsed":false,"id":"53a28548324d","title":"孩子表示法"},{"parent":"a994aa88d855","children":[{"parent":"7d75cc43ef94","children":[],"id":"352686c4f604","title":"从树结点的兄弟的角度来确定树的存储结构"},{"parent":"7d75cc43ef94","children":[],"id":"17f6724089a5","title":"对于任意一棵树,它的结点的第一个孩子如果存在肯定是唯一的  ,如果结点的右兄弟存<br>在也肯定是唯一的,可以设置两个指针分别指向某个结点的第一个孩子和它的右兄弟,如:<br>"},{"parent":"7d75cc43ef94","image":{"w":261,"h":49,"url":"http://cdn.processon.com/5ff30d467d9c0805640f954d?e=1609767766&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:gUYl11eTsV9qcOzuAWemJJtFva8="},"children":[],"id":"5a7bf14453eb","title":"<br>"},{"parent":"7d75cc43ef94","image":{"w":525,"h":296,"url":"http://cdn.processon.com/5ff30d5b7d9c0805640f956d?e=1609767787&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:4VDb4JKqSAzCXqZkskoiU17NTQM="},"children":[],"id":"244307e4cc76","title":"使用孩子兄弟法表示树的存储结构"},{"parent":"7d75cc43ef94","children":[],"id":"c32dacc9d8bc","title":"这种表示法,可以方便查找某个结点的孩子和右兄弟<br>"},{"parent":"7d75cc43ef94","children":[],"id":"201b7b9acd82","title":"这种表示法,把一棵复杂的树转换为一棵二叉树"}],"collapsed":false,"id":"7d75cc43ef94","title":"孩子兄弟表示法"}],"collapsed":false,"id":"a994aa88d855","title":"树的存储结构<br>"},{"parent":"dec8bf74a208","children":[{"parent":"4dccb68bd9d1","children":[{"parent":"6b6980e37ce0","children":[],"id":"1a0187227687","title":"二叉树(Binary  Tree)是由 n 个结点组成  的集合.  该集合要么是空集合,  要么是一个由<br>根结点和两棵互不相交的二叉树组成<br>"}],"collapsed":false,"id":"6b6980e37ce0","title":"二叉树的基本概念"},{"parent":"4dccb68bd9d1","children":[{"parent":"cf545cae8207","children":[],"id":"bd4def1effa5","title":"每个结点最多有两棵子树"},{"parent":"cf545cae8207","children":[],"id":"b4f745dfc682","title":"左子树与右子树是有顺序的<br>"},{"parent":"cf545cae8207","children":[],"id":"6b3d65b055bf","title":"即使树中的某个结点只有一个子树,也是区分左子树与右子树的"},{"parent":"cf545cae8207","children":[{"parent":"6a7b959996f3","children":[],"id":"fc82974439c4","title":"空二叉树<br>"},{"parent":"6a7b959996f3","children":[],"id":"b495b802da64","title":"只有一个结点的二叉树<br>"},{"parent":"6a7b959996f3","children":[],"id":"7355afbab520","title":"根结点只有左子树"},{"parent":"6a7b959996f3","children":[],"id":"8abd8e6e1ca8","title":"根结点只有右子树"},{"parent":"6a7b959996f3","children":[],"id":"a189a92c795e","title":"根结点既有左子树又有右子树"}],"collapsed":false,"id":"6a7b959996f3","title":"二叉树的五种基本形态"}],"collapsed":false,"id":"cf545cae8207","title":"二叉树的特点"},{"parent":"4dccb68bd9d1","children":[{"parent":"feeddae644c8","children":[{"parent":"f44714c485b7","children":[],"id":"a669dd2310bb","title":"所有结点都只有左子树的二叉树称为左斜树 ,  所有结点都保有右子树的二叉树称为右斜树<br>"}],"collapsed":true,"id":"f44714c485b7","title":"斜树<br>"},{"parent":"feeddae644c8","children":[{"parent":"f8c9d8a655f3","children":[],"id":"241a688b89c8","title":"在一棵二叉树中,  如果所有分支结点都有左子树和右子树,  并且所有叶子结点都在同一<br>层上,  这样的二叉树称为满二叉树,   即每层的结点都是满的<br>"},{"parent":"f8c9d8a655f3","image":{"w":314,"h":206,"url":"http://cdn.processon.com/5ff30e6be0b34d34e129b05b?e=1609768059&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:A7QXLgZHvq_McwxXe-xH6pmoGes="},"children":[],"id":"f9f49f9c10fb","title":""},{"parent":"f8c9d8a655f3","children":[{"parent":"fe9e8bd9a0b4","children":[],"id":"ecce286fb16a","title":"叶子结点只能出现最下面的一层<br>"},{"parent":"fe9e8bd9a0b4","children":[],"id":"9a8bba0770fc","title":"非叶子结点的度一定是2<br>"},{"parent":"fe9e8bd9a0b4","children":[],"id":"15476b090b7e","title":"在同样深度的二叉树中, 满二叉树的结点是最多的, 叶子也是最多的"}],"collapsed":false,"id":"fe9e8bd9a0b4","title":"满二叉树的特点<br>"}],"collapsed":false,"id":"f8c9d8a655f3","title":"满二叉树"},{"parent":"feeddae644c8","children":[{"parent":"9f453df9df1a","children":[],"id":"3db0ca80ffde","title":"对一棵具有 n 个结点的二叉树按层次编号, 如果编号为 i  的结点与同样深度的满二叉树<br>编号为 i 的结点在二叉树中的位置完全相同, 这就是一棵完全二叉树.<br>"},{"parent":"9f453df9df1a","children":[],"id":"f32a46a4841c","title":"将满二叉树从最下层的最右侧开始去掉相邻的若干叶子结点，都称为完全二叉树<br>"},{"parent":"9f453df9df1a","image":{"w":316,"h":223,"url":"http://cdn.processon.com/5ff30ee507912930e0186c4f?e=1609768181&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:3V61VYJjv3dzxwy8Vs7WjIzpqjc="},"children":[],"id":"8441a0b815ac","title":"完全二叉树"},{"parent":"9f453df9df1a","children":[],"id":"64aa25a678aa","title":"满二叉树肯定是一棵完全二叉树,但完全二叉树不一定是满的<br>"},{"parent":"9f453df9df1a","children":[{"parent":"9e3da592bef6","children":[],"id":"71b8005a58ae","title":"叶子结点只能出现在最下两层<br>"},{"parent":"9e3da592bef6","children":[],"id":"fe981352b134","title":"最下层的叶子结点集中在左侧连续的位置<br>"},{"parent":"9e3da592bef6","children":[],"id":"3b157d60db92","title":"倒数第二层的叶子结点一定都在右边连接的位置<br>"},{"parent":"9e3da592bef6","children":[],"id":"5a509285a41c","title":"如果结点的度为 1, 该结点只有左孩子<br>"},{"parent":"9e3da592bef6","children":[],"id":"60a09f8ea4c5","title":"同样结点数的二叉树, 完全二叉树的深度最小"}],"collapsed":false,"id":"9e3da592bef6","title":"满二叉树的特点"}],"collapsed":false,"id":"9f453df9df1a","title":"完全二叉树"}],"collapsed":false,"id":"feeddae644c8","title":"特殊的二叉树"},{"parent":"4dccb68bd9d1","children":[{"parent":"ca6d90ba9a6f","children":[{"parent":"d906a9b48ee6","children":[],"id":"a87dc3773555","title":"在二叉树的第 i 层上最多有2^(i-1) 个结点(i&gt;=1)<br>"},{"parent":"d906a9b48ee6","image":{"w":485,"h":225,"url":"http://cdn.processon.com/5ff30fc907912930e0186e3a?e=1609768409&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:XqZo8lH578ddUp1WlTf8k93k5g4="},"children":[],"id":"051908924cf0","title":""}],"collapsed":false,"id":"d906a9b48ee6","title":"性质1"},{"parent":"ca6d90ba9a6f","children":[{"parent":"1e036ccfbdd6","children":[],"id":"f6f4b6ae722f","title":"深度为 k 的二叉树,最多有(2^k) - 1  个结点"},{"parent":"1e036ccfbdd6","image":{"w":506,"h":218,"url":"http://cdn.processon.com/5ff30fd763768937162f1cfd?e=1609768423&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:-rBBRLxgPww5i8dQG-QEGbSmEzw="},"children":[],"id":"045c6ae02ef5","title":""}],"collapsed":false,"id":"1e036ccfbdd6","title":"性质2"},{"parent":"ca6d90ba9a6f","children":[{"parent":"4e2655c5e620","children":[],"id":"c88d48f70ca5","title":"对于任意一棵二叉树,  叶子结点的数量 n0, 度为 2 结点数量 n2, 则 n0 = n2 + 1"},{"image":{"w":325,"h":215,"url":"http://cdn.processon.com/5ff310101e08531de8180cf9?e=1609768480&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Qq1nErbOgcTWbjnT82NAu5gqlKc="},"parent":"4e2655c5e620","children":[],"id":"8330e0771850","title":""},{"parent":"4e2655c5e620","children":[],"id":"ae24f247aaf0","title":"结点之间连续的数量就是所有结点的数量减   1, 因为根结点没有连线进入,其他所有的结点都有连线进入.<br>"},{"parent":"4e2655c5e620","children":[],"id":"2fcc7664dc75","title":"分支线的总数 = 结点数 - 1<br>"},{"parent":"4e2655c5e620","children":[],"id":"7e9b22d83cb3","title":"n2*2 + n1 = n0+n1+n2 -1<br>"},{"parent":"4e2655c5e620","children":[],"id":"e138533dc711","title":"n2 = n0 -1<br>"},{"parent":"4e2655c5e620","children":[],"id":"7022ee16cf19","title":"n2 +1 = n0"}],"collapsed":true,"id":"4e2655c5e620","title":"性质3"},{"parent":"ca6d90ba9a6f","children":[{"parent":"956ab7edc95f","children":[],"id":"a87978b2e2a2","title":"具有 n 个结点的完全二叉树深度为   floor( log2为底n对数 ) +1"},{"parent":"956ab7edc95f","children":[],"id":"4bb9fe18011a","title":"满二叉树深度为k，结点总数量：(2^k) - 1，如果把总结点的数量记为n，即n=(2^k）-1 ，则k = log2为底n+1的对数"},{"parent":"956ab7edc95f","children":[],"id":"3501e88adce8","title":"深度为k 的完全二叉树结点数量n一定小于等于同样深度的满二叉树的结点数，一定大于深度为k-1的满二叉树结点的数量<br>即：<br>&nbsp; &nbsp; 2^(k-1) - 1 &lt; n &lt;= 2^k - 1 ，n就是深度为k的完全二叉树结点的数量<br>&nbsp; &nbsp; n &lt;= 2^k - 1，意味着 n &lt; 2^k<br>则：<br>&nbsp; &nbsp; 2^(k-1) &lt;= n &lt; 2^k<br>&nbsp; &nbsp; 对不等式的两边取对数，得到 k - 1 &lt;= log二为底n的对数 &lt; k<br>&nbsp; &nbsp; 因为k是深度，也是一个整数，floor(log2为底n的对数) + 1<br>&nbsp; &nbsp; floor(xx)是指小于等于xx的最大整数<br>"}],"collapsed":true,"id":"956ab7edc95f","title":"性质4"},{"parent":"ca6d90ba9a6f","children":[{"parent":"2171067fafbc","children":[],"id":"2a3a364c9afc","title":"对于一个完全二叉树进行按层次编号"},{"parent":"2171067fafbc","image":{"w":283,"h":202,"url":"http://cdn.processon.com/5ff31068e0b34d34e129b4f8?e=1609768569&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:LBrnGv4d4BpwNkU0hJyLS-ym1lY="},"children":[],"id":"3dabb75f928d","title":""},{"parent":"2171067fafbc","children":[],"id":"2e94fe2e9933","title":"对于任意一个结点 i,有:<br>&nbsp; &nbsp; &nbsp;如果 i==1,则结点 i 是二叉树的根<br>&nbsp; &nbsp; &nbsp;如果 i&gt;1,则该结点的双亲结点是  i/2<br>&nbsp; &nbsp; &nbsp;如果 2*i&gt;n, 则结点 i 没有左孩子,  否则左孩子是  2*i<br>&nbsp; &nbsp; &nbsp;如果 2*i + 1 &gt;n, 则结点 i 没有右孩子,  否则右孩子是  2*i+1<br>"}],"collapsed":true,"id":"2171067fafbc","title":"性质5"}],"collapsed":false,"id":"ca6d90ba9a6f","title":"二叉树的性质"},{"parent":"4dccb68bd9d1","children":[{"parent":"c454c3e97f11","children":[{"parent":"6857ce80cc3d","children":[],"id":"406926f4e1ec","title":"使用一维数组存储二叉树中的结点，结点的存储位置(数组的下标)可以反映结点之间的逻辑关系"},{"parent":"6857ce80cc3d","image":{"w":216,"h":182,"url":"http://cdn.processon.com/5ff57ce1e401fd661a19ae09?e=1609927410&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:CO5XXUHkdLgcUDimKGvEd5OIEOo="},"children":[],"id":"1cec4947107a","title":"完全二叉树的顺序存储，对完全二叉树的各个节点按层次编号"},{"image":{"w":443,"h":89,"url":"http://cdn.processon.com/5ff57d0a5653bb4ea20e9d25?e=1609927451&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:iyyDWj_an1xq72g80EkDjCtofG0="},"parent":"6857ce80cc3d","children":[],"id":"b86166d02864","title":"将完全二叉树存储到数组中，数组的下标对应存储位置"},{"parent":"6857ce80cc3d","image":{"w":506,"h":163,"url":"http://cdn.processon.com/5ff57d31f346fb340deb6330?e=1609927489&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:51T3FWPoL-r9kHIHHiM4T349mBc="},"children":[],"id":"2c950e61b16a","title":"如果不是完全二叉树，可以将二叉树编号，把不存在的结点设置为null"},{"parent":"6857ce80cc3d","children":[],"id":"d2d28de75217","title":"适用于：顺序存储只适用于完全二叉树"},{"parent":"6857ce80cc3d","children":[],"id":"da41f370c93c","title":"缺点：如果二叉树中有很多不存在的结点，会造成存储空间的浪费"}],"collapsed":false,"id":"6857ce80cc3d","title":"顺序存储"},{"parent":"c454c3e97f11","children":[{"parent":"ae81be2ae50c","children":[],"id":"905d40f83d62","title":"二叉树的结点最多有两个孩子  ,   可以为结点设计一个数据域,  一个指向左孩子的指针<br>域和一个指向右孩子的指针域,   由这样的结点组成的链表称为二叉链表<br>"},{"image":{"w":224,"h":78,"url":"http://cdn.processon.com/5ff57dc76376891d8b38d82f?e=1609927639&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:6E4ahcaDXg2KFvcVt9vV9H23YBE="},"parent":"ae81be2ae50c","children":[],"id":"f2fd3eb6aeac","title":"二叉树结点的结构可以设计为上图所示"},{"image":{"w":504,"h":165,"url":"http://cdn.processon.com/5ff57e0b1e08531de8203cea?e=1609927708&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:bHA7SGwcgYTycSVCUx6scuCAo04="},"parent":"ae81be2ae50c","children":[],"id":"08b933b33272","title":"以上二叉树的二叉链表如右图所示"},{"parent":"ae81be2ae50c","children":[{"parent":"497a61939798","children":[],"id":"63aa73a1f226","title":"改进：为了方便找到父结点,  可以在结点上增加一个指向父结点的的指针域, 这种结点组成的<br>链表称为三叉链表,&nbsp;<br>"},{"image":{"w":196,"h":41,"url":"http://cdn.processon.com/5ff57e891e08531de8203f8b?e=1609927834&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:bUKwDqKY4tcY7RnFG5hsfj-DRaw="},"parent":"497a61939798","children":[],"id":"689128ba0de3","title":"二叉树结点的结构可以设计为上图所示"},{"image":{"w":507,"h":211,"url":"http://cdn.processon.com/5ff57ed56376891d8b38de12?e=1609927909&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:qJFBHLL14fG5ca2kJ1X8wsSYNnw="},"parent":"497a61939798","children":[],"id":"17349032217b","title":"以上二叉树的三叉链表如上图所示"},{"parent":"497a61939798","children":[{"parent":"fa9b3c6f9181","children":[],"id":"e3dccb84df7c","title":"package pers.chenjiahao.tree.binarytreenode;<br><br>/**<br> * 三叉链表的结点<br> */<br>public class BinaryTreeNode {<br>    // 数据域<br>    private Object date;<br>    // 父结点指针域<br>    private BinaryTreeNode parent;<br>    // 左孩子指针域<br>    private BinaryTreeNode lChild;<br>    // 右孩子指针域<br>    private BinaryTreeNode rChild;<br>    // 以当前结点为根结点的二叉树的高度<br>    private int height;<br>    // 以当前结点为根结点的二叉树所偶结点的数量<br>    private int size;<br><br>    // 根据指定的数据，创建一个结点<br>    public BinaryTreeNode(Object date) {<br>        this.date = date;<br>        parent = null;<br>        lChild = null;<br>        rChild = null;<br>        height = 1; // 二叉树的高度从1开始<br>        size = 1;<br>    }<br><br>    public BinaryTreeNode() {<br>        this(null);<br>    }<br><br>/*********判断当前结点的情况*********/<br><br>    // 判单当前结点是否有父节点<br>    public boolean hasParent(){<br>        return parent != null;<br>    }<br><br>    // 判断是否有左孩子<br>    public boolean hasLChild(){<br>        return lChild != null;<br>    }<br><br>    // 判断是否有右孩子<br>    public boolean hasRChild(){<br>        return rChild != null;<br>    }<br><br>    // 判断是否为叶子结点<br>    public boolean isLeaf(){<br>        return lChild == null &amp;&amp; rChild == null;<br>    }<br><br>    // 判断是否为父节点的左孩子<br>    public boolean isLChild(){<br>        return parent != null &amp;&amp; parent.lChild == this;<br>    }<br><br>    // 判断是否为父节点的右孩子<br>    public boolean isRChild(){<br>        return parent != null &amp;&amp; parent.rChild == this;<br>    }<br><br>/*********与height相关的操作*********/<br><br>    // 返回高度<br>    public int getHeight(){<br>        return height;<br>    }<br>    // 更新当前结点的高度，祖先结点的高度<br>    public void updateHeight(){<br>        // 定义一个变量,保存新的高度<br>        int newHeight = 0;<br>        // 当前结点的高度为 左子树的高度 或 右子树的高度 较大的那个再加一<br>        if (hasLChild()){<br>            newHeight = Math.max(newHeight,getLChild().getHeight() + 1);<br>        }<br><br>        if (hasRChild()){<br>            newHeight = Math.max(newHeight,getRChild().getHeight() + 1);<br>        }<br>        // 如果当前结点的高度有变化，递归更新祖先结点的高度<br>        if (newHeight == height){<br>            // 如果计算出来的高度与原来的高度一样，不需要更新祖先的高度<br>            return;<br>        }<br>        // 把新的高度作为当前结点的高度<br>        height = newHeight;<br>        // 更新祖先结点的高度<br>        if (hasParent()){<br>            getParent().updateHeight();<br>        }<br>    }<br><br>    /*****与size结点个数相关的操作*****/<br>    // 返回以当前结点为根的二叉树的结点数<br>    public int getSize(){<br>        return size;<br>    }<br><br>    // 更新当前结点及祖先的结点数<br>    public  void updateSize(){<br>        // 当前结点本身<br>        size = 1;<br>        // 累加左子树的结点数<br>        if (hasLChild()){<br>            size += getLChild().getSize();<br>        }<br>        // 累加右子树的结点数<br>        if (hasRChild()){<br>            size += getRChild().getSize();<br>        }<br>        // 递归更新一下祖先结点数<br>        if (hasParent()){<br>            getParent().updateSize();<br>        }<br>    }<br><br>    /***********与父结点相关的操作****************************/<br>    // 返回父结点<br>    public BinaryTreeNode getParent(){<br>        return parent;<br>    }<br><br>    // 断开与父结点的关系<br>    public void disInheritance(){<br>        // 如果没有父结点<br>        if (!hasParent()){<br>            return;<br>        }<br>        // 需改父结点的左孩子或右孩子为null<br>        if (isLChild()){<br>            // 如果当前结点是父结点的左孩子<br>            parent.lChild = null;<br>        }else if(isRChild()){<br>            // 如果当前结点是父结点的右孩子<br>            parent.rChild = null;<br>        }<br>        // 更新父结点的高度<br>        parent.updateHeight();<br>        // 更新结点数<br>        parent.updateSize();<br>        // 修改当前结点的父结点指针<br>        parent = null;<br>    }<br><br>    /***********与左孩子相关的操作****************************/<br>    // 返回左子树（左孩子）<br>    public BinaryTreeNode getLChild(){<br>        return lChild;<br>    }<br><br>    // 设置当前结点的左孩子，把原来的左孩子返回<br>    public BinaryTreeNode setLChild(BinaryTreeNode newLChild){<br>        // 保存原来的左孩子<br>        BinaryTreeNode oldLChild = this.lChild;<br>        // 先断开当前结点的左孩子<br>        if (hasLChild()){<br>            lChild.disInheritance();<br>        }<br>        // 设置新的左孩子为参数结点<br>        if (newLChild != null){<br>            // 先把参数结点断开与原来父结点的关系<br>            newLChild.disInheritance();<br>            // 把参数结点设置为左孩子<br>            this.lChild = newLChild;<br>            // 设置参数结点的父结点<br>            newLChild.parent = this;<br>            this.updateHeight();<br>            this.updateSize();<br>        }<br>        // 返回原来的左孩子结点<br>        return oldLChild;<br>    }<br><br>    /***********与右孩子相关的操作****************************/<br>    // 返回右子树（右孩子）<br>    public BinaryTreeNode getRChild(){<br>        return rChild;<br>    }<br><br>    // 设置右孩子<br>    public BinaryTreeNode setRChild(BinaryTreeNode newRChild){<br>        // 保存原来的右孩子<br>        BinaryTreeNode oldRChild = this.rChild;<br>        // 断开右孩子结点<br>        if (hasRChild()){<br>            rChild.disInheritance();<br>        }<br>        // 设置右孩子结点<br>        if (newRChild != null){<br>            // 参数结点先断开与原来父结点的关系<br>            newRChild.disInheritance();<br>            // 设置当前结点的右孩子<br>            this.rChild = newRChild;<br>            newRChild.parent = this;<br>            this.updateHeight();<br>            this.updateSize();<br>        }<br>        return oldRChild;<br>    }<br><br>    public Object getDate(){<br>        return date;<br>    }<br>}<br>"}],"collapsed":true,"id":"fa9b3c6f9181","title":"代码"}],"collapsed":true,"id":"497a61939798","title":"改进方案"}],"collapsed":false,"id":"ae81be2ae50c","title":"链式存储"}],"collapsed":false,"id":"c454c3e97f11","title":"二叉树的存储结构"},{"parent":"4dccb68bd9d1","children":[{"parent":"8d9e24133c2b","children":[],"id":"b669b76da5f6","title":"二叉树的遍历就是从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结<br>点被访问一次并且只访问一次.<br>"},{"parent":"8d9e24133c2b","children":[],"id":"ed63be6f2076","title":"按照结点被访问的次序,可以得到  由二叉树所有结点组成的一个序列.<br>"},{"parent":"8d9e24133c2b","children":[{"parent":"961022c8bc6e","children":[],"id":"2ce2c1c9bbdd","title":"先序遍历,  先根序遍历, DLR(Data,   LChilld,   RChild)<br>"},{"parent":"961022c8bc6e","children":[],"id":"824dea6e2ba9","title":"如果二叉树为空,则是空操作; 否则先访问根结点, 前序遍历左子树, 前序遍历右子树."},{"parent":"961022c8bc6e","image":{"w":479,"h":206,"url":"http://cdn.processon.com/5ff5813af346fb340deb7943?e=1609928522&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0x3EoeMNm2s_z0Pc1rCJuwuZvHQ="},"children":[],"id":"285f31385aac","title":""}],"collapsed":false,"id":"961022c8bc6e","title":"先序遍历"},{"parent":"8d9e24133c2b","children":[{"parent":"bad160bede80","children":[],"id":"08a5f37bf7df","title":"如果二叉树为空,则是空操作;   否则,  中序遍历左子树,  访问根结点,  中序遍历右子树"},{"image":{"w":487,"h":197,"url":"http://cdn.processon.com/5ff581475653bb4ea20eb49b?e=1609928535&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:vcr455S6wVYy2NOPxG_z5jq6cZA="},"parent":"bad160bede80","children":[],"id":"18f1cb5448be","title":""}],"collapsed":false,"id":"bad160bede80","title":"中序遍历"},{"parent":"8d9e24133c2b","children":[{"parent":"a744a75b78e7","children":[],"id":"ac3a8a719e15","title":"后序遍历, LRD<br>"},{"parent":"a744a75b78e7","children":[],"id":"19b30bc23348","title":"如果二叉树为空则 是空操作; 否则, 后序遍历左子树, 后序遍历右子树, 访问根"},{"image":{"w":471,"h":182,"url":"http://cdn.processon.com/5ff581505653bb4ea20eb4da?e=1609928544&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Kvol9hkZaeMZYlns_QfJBM4kSAk="},"parent":"a744a75b78e7","children":[],"id":"8c10669fec5a","title":""}],"collapsed":false,"id":"a744a75b78e7","title":"后序遍历"},{"parent":"8d9e24133c2b","children":[{"parent":"8d8f18e61bb1","children":[],"id":"9ef1e54a1ec4","title":"从树的第一层,  即从根结点开始访问, 从上到下逐层遍历,  在同一层中,按从左到右的顺<br>序对结点逐个访问<br>"},{"image":{"w":507,"h":183,"url":"http://cdn.processon.com/5ff58158e401fd661a19c7ac?e=1609928553&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:oqSFejTHUCLEQHALl_D2KVY8LSg="},"parent":"8d8f18e61bb1","children":[],"id":"00aece25cd01","title":""}],"collapsed":false,"id":"8d8f18e61bb1","title":"层序遍历"},{"parent":"8d9e24133c2b","children":[{"parent":"2af7d82bdead","children":[],"id":"272af3616d4f","title":"package pers.chenjiahao.tree.binarytree;<br><br>import pers.chenjiahao.tree.binarytreenode.BinaryTreeNode;<br><br>import java.util.LinkedList;<br><br>/**<br> * 使用三叉链表创建二叉树<br> */<br>public class BinaryTree {<br>    // 二叉树的根结点<br>    private BinaryTreeNode root;<br><br>    // 构造方法<br>    public BinaryTree(BinaryTreeNode root) {<br>        this.root = root;<br>    }<br><br>    // 返回元素的个数<br>    public int getSize(){<br>        if (root == null){<br>            // 空树<br>            return 0;<br>        }<br>        return root.getSize();<br>    }<br><br>    // 判断二叉树是否为空<br>    public boolean isEmpty(){<br>        return getSize() == 0;<br>    }<br><br>    // 返回根结点<br>    public BinaryTreeNode getRoot() {<br>        if (root != null){<br>            return root;<br>        }<br>        return null;<br>    }<br><br>    // 返回树的高度<br>    public int getHeight(){<br>        if (root == null){<br>            return 0;<br>        }<br>        return root.getHeight();<br>    }<br><br>    /***********二叉树的先序遍历*********************/<br>    // 先序遍历二叉树，把遍历的结点存储到List列表中<br>    private void preOrderRecursion(BinaryTreeNode root,LinkedList&lt;Object&gt; list){<br>        if (root == null){<br>            return;<br>        }<br>        // 先访问根结点，把根结点存储到列表中<br>        list.add(root.getDate());<br>        // 递归，先序遍历左子树<br>        preOrderRecursion(root.getLChild(),list);<br>        // 递归，先序遍历右子树<br>        preOrderRecursion(root.getRChild(),list);<br>    }<br>    // 打印当前二叉树的先序遍历序列<br>    public void preOrder(){<br>        LinkedList&lt;Object&gt; list = new LinkedList&lt;&gt;();<br>        preOrderRecursion(root,list);<br>        System.out.println(list);<br>    }<br><br>    /***********二叉树的中序遍历*********************/<br>    private void inOrderRecursion(BinaryTreeNode root,LinkedList&lt;Object&gt; list){<br>        if (root == null){<br>            return;<br>        }<br>        // 递归遍历左子树<br>        inOrderRecursion(root.getLChild(),list);<br>        // 访问根<br>        list.add(root.getDate());<br>        // 递归遍历右子树<br>        inOrderRecursion(root.getRChild(),list);<br>    }<br>    public void inOrder(){<br>        LinkedList&lt;Object&gt; list = new LinkedList&lt;&gt;();<br>        inOrderRecursion(root,list);<br>        System.out.println(list);<br>    }<br><br>    /***********二叉树的后序遍历*********************/<br>    private void postOrderRecursion(BinaryTreeNode root,LinkedList&lt;Object&gt; list){<br>        if (root == null){<br>            return;<br>        }<br>        // 递归遍历左子树<br>        postOrderRecursion(root.getLChild(),list);<br>        // 递归遍历右子树<br>        postOrderRecursion(root.getRChild(),list);<br>        // 访问根<br>        list.add(root.getDate());<br>    }<br>    public void postOrder(){<br>        LinkedList&lt;Object&gt; list = new LinkedList&lt;&gt;();<br>        postOrderRecursion(root,list);<br>        System.out.println(list);<br>    }<br><br>    /***********二叉树的层序遍历*********************/<br>    private void levelOrderTraverse(BinaryTreeNode root,LinkedList&lt;Object&gt; list){<br>        if (root == null){<br>            return;<br>        }<br>        // 定义一个队列，存储结点<br>        LinkedList&lt;BinaryTreeNode&gt; queue = new LinkedList&lt;&gt;();<br>        // 根结点入队<br>        queue.offer(root);<br>        while(!queue.isEmpty()){<br>            // 把队列头部的结点取出来<br>            BinaryTreeNode node = queue.poll();<br>            // 把结点的数据添加到list列表中<br>            list.add(node.getDate());<br>            // 分别把node的左结点和右结点入队<br>            if (node.hasLChild()){<br>                queue.offer(node.getLChild());<br>            }<br>            if (node.hasRChild()){<br>                queue.offer(node.getRChild());<br>            }<br>        }<br>    }<br>    public void levelOrder(){<br>        LinkedList&lt;Object&gt; list = new LinkedList&lt;&gt;();<br>        levelOrderTraverse(root,list);<br>        System.out.println(list);<br>    }<br>}<br>"}],"collapsed":true,"id":"2af7d82bdead","title":"代码"},{"parent":"8d9e24133c2b","children":[{"parent":"d657d6f8ead7","children":[],"id":"c7e75005253f","title":"package pers.chenjiahao.tree.test;<br><br>import pers.chenjiahao.tree.binarytree.BinaryTree;<br>import pers.chenjiahao.tree.binarytreenode.BinaryTreeNode;<br><br>/**<br> * 测试二叉树的遍历序列<br> */<br>public class Test {<br>    public static void main(String[] args) {<br>        // 创建根结点<br>        BinaryTreeNode root = new BinaryTreeNode(\"oo\");<br><br>        BinaryTreeNode xx = new BinaryTreeNode(\"xx\");<br>        BinaryTreeNode yy = new BinaryTreeNode(\"yy\");<br>        root.setLChild(xx);<br>        root.setRChild(yy);<br><br>        BinaryTreeNode xl = new BinaryTreeNode(\"xll\");<br>        BinaryTreeNode xr = new BinaryTreeNode(\"xrr\");<br>        xx.setLChild(xl);<br>        xx.setRChild(xr);<br><br>        BinaryTreeNode yr = new BinaryTreeNode(\"yrr\");<br>        yy.setRChild(yr);<br><br>        BinaryTree tree = new BinaryTree(root);<br>        // 先序遍历<br>        tree.preOrder();<br>        // 中序遍历<br>        tree.inOrder();<br>        // 后序遍历<br>        tree.postOrder();<br>        // 层序遍历<br>        tree.levelOrder();<br><br>    }<br>}<br>"}],"collapsed":true,"id":"d657d6f8ead7","title":"测试类"}],"collapsed":false,"id":"8d9e24133c2b","title":"二叉树的遍历"}],"collapsed":false,"id":"4dccb68bd9d1","title":"二叉树"}],"collapsed":true,"id":"dec8bf74a208","title":"5.树"}],"collapsed":false,"id":"270b57d67f7f","title":"数据结构<br>"},{"parent":"root","children":[{"parent":"de0d58c51179","children":[{"parent":"3eb188c222ad","children":[],"id":"bf38dbe93152","title":"算法就是为了解决某一个特定问题而规定的一系列的操作，是一组有序的指令的集合<br>"},{"parent":"3eb188c222ad","children":[],"id":"66913116d2db","title":"数据结构与算法就是一对好兄弟"},{"parent":"3eb188c222ad","children":[{"parent":"191e70ad21d3","children":[{"parent":"a90f14d718ed","children":[],"id":"bfec671bd070","title":"一个算法有0个或多个输入"}],"id":"a90f14d718ed","title":"输入"},{"parent":"191e70ad21d3","children":[{"parent":"b198048c9825","children":[],"id":"c726e967c92f","title":"至少有一个输出，没有输出的算法没有意义"}],"id":"b198048c9825","title":"输出<br>"},{"parent":"191e70ad21d3","children":[{"parent":"242f82c70899","children":[],"id":"a9ab63e056d0","title":"算法中执行指令的个数应该是有限的，执行有穷的步骤后能结束"}],"id":"242f82c70899","title":"有穷性"},{"parent":"191e70ad21d3","children":[{"parent":"fedf397dc589","children":[],"id":"0b867f8e5e67","title":"对于特定的合法输入它的输出应该是唯一的"}],"id":"fedf397dc589","title":"确定性"},{"parent":"191e70ad21d3","children":[{"parent":"33895fb04e6e","children":[],"id":"3f39e70bb96d","title":"算法能够实现，并且在有限的时间内完成"}],"id":"33895fb04e6e","title":"可行性"}],"id":"191e70ad21d3","title":"算法的五个特性"},{"parent":"3eb188c222ad","children":[{"parent":"5d94a5a47a01","children":[{"parent":"171574176f3f","children":[],"id":"b207280c4929","title":"没有语法错误，对于合法的输入能够产生满足要求的输出，对于特定的输入也能够产生正确的输出<br>"}],"id":"171574176f3f","title":"正确性<br>"},{"parent":"5d94a5a47a01","children":[{"parent":"9fdf89b9e0f3","children":[],"id":"aa5cf4037195","title":"算法另一个目的是为了交流，方便阅读"}],"id":"9fdf89b9e0f3","title":"可读性"},{"parent":"5d94a5a47a01","children":[{"parent":"f7e19ded2629","children":[],"id":"289bddba644d","title":"对于不合理的要求，能够给出合理的提示信息，而不是崩溃"}],"id":"f7e19ded2629","title":"健壮性<br>"},{"parent":"5d94a5a47a01","children":[],"id":"b4b6320de38c","title":"时间效率高与存储空间小"},{"parent":"5d94a5a47a01","children":[{"parent":"7d5cd408c25a","children":[],"id":"0e592d0d19cc","title":"评价一个算法性能的优劣，实际上就是评价算法的资源占用率<br>计算机最重要的资源就是时间和空间<br>"},{"parent":"7d5cd408c25a","children":[],"id":"9c3362d45275","title":"使用时间复杂度衡量程序运行需要的时间"},{"parent":"7d5cd408c25a","children":[],"id":"b1feb762577b","title":"使用空间复杂度衡量程序所占内存的大小"}],"id":"7d5cd408c25a","title":"算法的评价"}],"id":"5d94a5a47a01","title":"算法的设计要求"}],"collapsed":true,"id":"3eb188c222ad","title":"基本概念"},{"parent":"de0d58c51179","children":[{"parent":"9c4dbb83dc82","children":[],"id":"33c3ad8811a5","title":"程序中语句执行的次数"},{"parent":"9c4dbb83dc82","children":[{"parent":"0cec25cc4829","children":[{"parent":"a0c9de710c73","children":[],"id":"b0b0205e57ed","title":"编程实现这个算法，统计所需要的时间"}],"id":"a0c9de710c73","title":"事后统计"},{"parent":"0cec25cc4829","children":[{"parent":"4e827661b669","children":[],"id":"185973e22db8","title":"采用渐近时间复杂度分析估算"}],"id":"4e827661b669","title":"事前分析"}],"collapsed":true,"id":"0cec25cc4829","title":"计算机程序运行时间的方法"},{"parent":"9c4dbb83dc82","children":[{"parent":"4a3cfb304154","children":[],"id":"6e3f6df14240","title":"简称时间复杂度。在进行算法分析时，语句总的执行次数，记作T(n)，<br>是关于问题规模n的函数，分析T(n)随着问题规模n的变化情况，确定T(n)的数量级"},{"parent":"4a3cfb304154","children":[],"id":"d5cb9c7f5f70","title":"T(n) = O(f(n))，表示锁着问题规模n的增大，算法执行的时间增长率和f(n)函数的增长率相同，<br>f(n)是问题规模n的一个函数"},{"parent":"4a3cfb304154","children":[],"id":"6f16a77b6785","title":"随着输入规模n的增大，T(n)增长越慢的算法越好"}],"collapsed":true,"id":"4a3cfb304154","title":"渐近时间复杂度"},{"parent":"9c4dbb83dc82","children":[{"parent":"f9be89ced4ad","children":[{"parent":"0c2844a63cac","children":[],"id":"82267d04ed2d","title":"计算次数为：2n + 1<br>时间复杂度为：O(n)"}],"collapsed":true,"id":"0c2844a63cac","title":"忽略常数项"},{"parent":"f9be89ced4ad","children":[{"parent":"0a40a611891b","children":[],"id":"98ef863d7d8e","title":"计算次数为：n^2 + n<br>时间复杂度为：O(n^2)"}],"collapsed":true,"id":"0a40a611891b","title":"忽略低次项"},{"parent":"f9be89ced4ad","children":[{"parent":"edb58139c018","children":[],"id":"3c4d94cd2646","title":"随着问题规模的增大，常数项和低次项对于结果的影响非常小，<br>所以常数项和低次项都可以忽略<br>"}],"collapsed":true,"id":"edb58139c018","title":"可以忽略的原因"}],"collapsed":true,"id":"f9be89ced4ad","title":"时间复杂度计算的一些原则"}],"collapsed":true,"id":"9c4dbb83dc82","title":"时间复杂度<br>"},{"parent":"de0d58c51179","children":[{"parent":"cca23a939a51","children":[{"parent":"14735265db4a","children":[],"id":"61906ad8b994","title":"计算1+2+3+...+n的累加和，高斯算法"},{"parent":"14735265db4a","children":[],"id":"6246bc0777ed","title":"public static void sum2(int n){<br>&nbsp; &nbsp; &nbsp; &nbsp;int sum = n * (n + 1) / 2;<br>&nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"高斯sum = \" + sum);<br>    }"},{"parent":"14735265db4a","children":[],"id":"b6ae0dd56092","title":"总共执行了1次"},{"parent":"14735265db4a","children":[],"id":"07b48b98bd55","title":"顺序执行，时间复杂度：T(n) = O(1)，是常数阶"}],"collapsed":true,"id":"14735265db4a","title":"算法1"},{"parent":"cca23a939a51","children":[{"parent":"8cc9025805aa","children":[],"id":"d348c35981e5","title":"计算1+2+3+...+n的累加和<br>"},{"parent":"8cc9025805aa","children":[],"id":"5cfdbb28b7fa","title":"public static void sum1(int n){<br>&nbsp; &nbsp; &nbsp; &nbsp;int sum = 0;<br>&nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt;= n; i++) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum += i;<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"for循环sum = \" + sum);<br>    }"},{"parent":"8cc9025805aa","children":[],"id":"c8fbbe4bb66d","title":"总共执行了 n + 1 次，1是常数 对结果的影响不大，所以可以省略"},{"parent":"8cc9025805aa","children":[],"id":"7cc32be8950a","title":"时间复杂度：T(n) = O(n)，是线性阶<br>"}],"collapsed":true,"id":"8cc9025805aa","title":"算法2"},{"parent":"cca23a939a51","children":[{"parent":"c0a116039238","children":[],"id":"55bd95555e42","title":"public static void method1(int n){<br>&nbsp; &nbsp; &nbsp; &nbsp;int i = 1;<br>&nbsp; &nbsp; &nbsp; &nbsp;int count = 0;<br>&nbsp; &nbsp; &nbsp; &nbsp;while (i &lt;= n){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = i * 2;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"count==\" + count);<br>    }"},{"image":{"w":474,"h":28,"url":"http://cdn.processon.com/5fd85855f346fb07100f9239?e=1608017509&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:lwyVLKrcSktC7n3dCrd4VDYvUf4="},"parent":"c0a116039238","children":[],"id":"5514c338d338","title":""},{"parent":"c0a116039238","image":{"w":263,"h":24,"url":"http://cdn.processon.com/5fd85895e0b34d06f4f7c019?e=1608017573&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:prmy5y6AtIkPfReVDMnBXnwghNk="},"children":[],"id":"9f731930f0e5","title":"<br>"},{"image":{"w":96,"h":35,"url":"http://cdn.processon.com/5fd85a6f07912906da572323?e=1608018047&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:24xXi2VY6xC-aZYO48q_AlbtItw="},"parent":"c0a116039238","children":[],"id":"f415de9cb828","title":"解得x如上，其中：<br>常数2对结果影响不大可以忽略，底数2也可以忽略"},{"parent":"c0a116039238","children":[],"id":"87dccdbb6c9d","title":"时间复杂度：T(n) = O(logn)"}],"collapsed":true,"id":"c0a116039238","title":"算法3"},{"parent":"cca23a939a51","children":[{"parent":"356862cc8826","children":[],"id":"d20178288891","title":"public static void method2(int n){<br>&nbsp; &nbsp; &nbsp; &nbsp;int count = 0;<br>&nbsp; &nbsp; &nbsp; &nbsp;int s = 0;<br>&nbsp; &nbsp; &nbsp; &nbsp;while (s &lt;= n){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = s + count;<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"count==\" + count);<br>    }"},{"parent":"356862cc8826","children":[],"id":"aaf900e42de6","title":"假设循环执行了x次,count变量在循环过程中的值分别是：0,1,2,3,...x"},{"parent":"356862cc8826","children":[],"id":"b6d9ecd4c6b5","title":"在执行完第x次后循环结束,s&lt;=n不成立时，s的值是：<br>s = 0 + 1 + 2 + 3 + ... + x = x * (x + 1) / 2 = (x^2 + x)/2"},{"parent":"356862cc8826","children":[],"id":"7463e569c3c1","title":"时间复杂度：T(n) = O(n^2)"}],"collapsed":true,"id":"356862cc8826","title":"算法4"},{"parent":"cca23a939a51","children":[{"parent":"692b429a80d9","children":[],"id":"1b736e2f4bab","title":"public static void method3(int n){<br>&nbsp; &nbsp; &nbsp; &nbsp;int count = 0;<br>&nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt;= n; i++) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int j = 1; j &lt;= n; j++) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;count++;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"count=\" + count);<br>    }<br>"},{"parent":"692b429a80d9","children":[],"id":"a10497b23d49","title":"总共执行了n*n次"},{"parent":"692b429a80d9","children":[],"id":"f1f230237999","title":"时间复杂度：T(n) = O(n^2)"}],"collapsed":true,"id":"692b429a80d9","title":"算法5"},{"parent":"cca23a939a51","children":[{"parent":"a74873e7218d","children":[],"id":"33270f3b9e1c","title":"时间复杂度为：O(n)"}],"collapsed":true,"id":"a74873e7218d","title":"数组的平均数"},{"parent":"cca23a939a51","children":[{"image":{"w":418,"h":289,"url":"http://cdn.processon.com/5fd85c26e0b34d06f4f7da48?e=1608018486&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:HCh2JuzFQ-CVhX18ymCQ230ynU0="},"parent":"35bc32716a27","children":[],"id":"c67f4a0155b6","title":"图解"}],"collapsed":true,"id":"35bc32716a27","title":"常见时间复杂度的增长率"}],"collapsed":true,"id":"cca23a939a51","title":"时间复杂度分析"},{"parent":"de0d58c51179","children":[{"parent":"496d5d0779c3","children":[],"id":"43c865be71f2","title":"为了求解某一问题，在执行操作期间所需要的存储空间大小，<br>不包含用来存储输入所需要的空间<br>"},{"parent":"496d5d0779c3","children":[],"id":"0ebf9f2631c2","title":"空间复杂度就是算法需要用到的额外空间"},{"parent":"496d5d0779c3","children":[],"id":"5271cd0896b9","title":"记作：S(n) = O(f(n))"},{"parent":"496d5d0779c3","children":[],"id":"645d981cfe72","title":"结论：算法的空间复杂度是以时间复杂度为上限的"}],"collapsed":true,"id":"496d5d0779c3","title":"空间复杂度"},{"parent":"de0d58c51179","children":[{"parent":"5e70708e8d4b","image":{"w":900,"h":432.53968253968253,"url":"http://cdn.processon.com/5ff68f4ce401fd661a1bafcf?e=1609997660&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:qMo8ZnzHP23Ov2kzZStr7-kl5A8="},"children":[],"id":"65befa012c24","title":"引自马士兵老师"}],"collapsed":true,"id":"5e70708e8d4b","title":"常见排序列表图"},{"parent":"de0d58c51179","children":[{"parent":"961ffb5ab85b","children":[],"id":"8418e1e3e8d8","title":"选泡插，<br>快归堆希统计基，<br>恩方恩老恩一三，<br>对恩加 K恩乘 K，<br>不稳稳稳不稳稳，<br>不稳不稳稳稳稳！"},{"parent":"961ffb5ab85b","children":[],"id":"5d9e918cb89d","title":"解析：<br>&nbsp; &nbsp; &nbsp; &nbsp;恩方：对应选、泡、插的平均时间复杂度<br>&nbsp; &nbsp; &nbsp; &nbsp;恩老恩：对应快、归、堆的平均时间复杂度<br>&nbsp; &nbsp; &nbsp; &nbsp;一三：对应希尔排序的平均时间复杂度<br>&nbsp; &nbsp; &nbsp; &nbsp;对恩加K：对应桶排序和计数排序的平均时间复杂度<br>&nbsp; &nbsp; &nbsp; &nbsp;恩乘K：对应基数排序的平均时间复杂度<br>"}],"collapsed":true,"id":"961ffb5ab85b","title":"排序算法宋词记忆法(引用自马士兵老师)"},{"parent":"de0d58c51179","children":[{"parent":"e788f16cfe76","children":[],"id":"5a743c39c6cd","title":"两个相等的数字在数组排完顺序之后，它们的相对顺序可能会变化<br>"}],"collapsed":true,"id":"e788f16cfe76","title":"算法的稳定性"},{"parent":"de0d58c51179","children":[{"parent":"aa8bbf6ad7bb","children":[{"parent":"02bb750f39ac","children":[],"id":"29c12818b345","title":"验证一步走一步"},{"parent":"02bb750f39ac","children":[],"id":"4f28ef8555da","title":"多打印中间结果"}],"collapsed":true,"id":"02bb750f39ac","title":"由简单到复杂"},{"parent":"aa8bbf6ad7bb","children":[{"parent":"b7e324f493ba","children":[],"id":"a50522b2c8a0","title":"没思路时先细分"}],"collapsed":true,"id":"b7e324f493ba","title":"先局部后整体"},{"parent":"aa8bbf6ad7bb","children":[{"parent":"0aa419f822b1","children":[],"id":"98c1778aa0fc","title":"变量更名"},{"parent":"0aa419f822b1","children":[],"id":"89913431e0c7","title":"语句合并"},{"parent":"0aa419f822b1","children":[],"id":"adb6d78317f5","title":"边界处理"}],"collapsed":true,"id":"0aa419f822b1","title":"先粗糙后精细"},{"parent":"aa8bbf6ad7bb","children":[],"id":"2e6711dddb1a","title":"如果很难下手，就把每个小模块都封装成方法，慢慢来"}],"collapsed":true,"id":"aa8bbf6ad7bb","title":"写算法的原则"},{"parent":"de0d58c51179","children":[{"parent":"31db06af1347","children":[],"id":"dfdb53faf386","title":"package pers.chenjiahao.algorithm.check;<br><br>import pers.chenjiahao.algorithm.selection.MyselfSelectionSort;<br><br>import java.util.Arrays;<br>import java.util.Random;<br><br>public class DataChecker {<br>    static int[] generateRandomArray(){<br>        Random r = new Random();<br>        int[] arr = new int[1000];<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            arr[i] = r.nextInt(1000);<br>        }<br>        return arr;<br>    }<br><br>    static void check(){<br>        int[] arr = generateRandomArray();<br>        int[] arr2 = new int[arr.length];<br>        System.arraycopy(arr,0,arr2,0,arr.length);<br>        Arrays.sort(arr);<br>        MyselfSelectionSort.selectionSort(arr2);<br>        boolean same = true;<br>        for (int i = 0; i &lt; arr2.length; i++) {<br>            if (arr[i] != arr2[i]){<br>                same = false;<br>            }<br>        }<br>        System.out.println(same == true ? \"right\" : \"wrong\");<br>    }<br><br>    public static void main(String[] args) {<br>        check();<br>    }<br>}<br>"}],"collapsed":true,"id":"31db06af1347","title":"算法的验证"},{"parent":"de0d58c51179","children":[{"parent":"5acd06259d54","children":[{"parent":"ff211bc3acef","children":[],"id":"d78ccb4963ce","title":"计算1+2+3+...+n的累加和<br>"},{"parent":"ff211bc3acef","children":[],"id":"146767d0e036","title":"算法思想：<br>&nbsp; &nbsp; &nbsp; &nbsp;sum =  1  +  2 +  3 +  4 +  5 + ... + 100<br>&nbsp; &nbsp; &nbsp; &nbsp;sum = 100 + 99 + 98 + 97 + 96 + ... +  1&nbsp;<br>每一项对应相加 也就是二倍的sum<br>&nbsp; &nbsp; &nbsp; &nbsp;2倍的sum = 101 + 101 + 101 + 101 + ... + 101<br>一共有100个101<br>&nbsp; &nbsp; &nbsp; &nbsp;2 * sum = 100 * 101<br>解得：<br>&nbsp; &nbsp; &nbsp; &nbsp;sum = 100 * 101 / 2<br>即：<br>&nbsp; &nbsp; &nbsp; &nbsp;sum = n * (n + 1) / 2"}],"collapsed":true,"id":"ff211bc3acef","title":"1.高斯算法"},{"parent":"5acd06259d54","children":[{"parent":"b81d1c0ad642","children":[],"id":"379441455cd3","title":"在一个数组中，从第一个位置开始在数组中寻找最小的数字，<br>找到最小的数字之后和第一个位置上的数字进行交换，<br>换完之后第一个位置就是最小的数字了，然后第一个位置不参与排序了，<br>再从第二个位置开始在数组中寻找最小的数字，<br>找到后和第二个位置上的数字交换，以此类推。。。。。。"},{"parent":"b81d1c0ad642","children":[],"id":"f9362fce80dd","title":"怎么找最小的数：<br>&nbsp; &nbsp; &nbsp; &nbsp;每次将开始位置设置为最小数，<br>&nbsp; &nbsp; &nbsp; &nbsp;如果这个最小数大于下一个位置上的数字，将下一个位置上的数设置为最小数<br>&nbsp; &nbsp; &nbsp; &nbsp;如果比下一个位置上的数字小，那么最小数还是它本身<br>&nbsp; &nbsp; &nbsp; &nbsp;全部比较完之后，将最小数的位置和开始位置进行交换，这样就、完成了一次排序"},{"parent":"b81d1c0ad642","children":[{"parent":"ebde1ffbb6dc","children":[],"id":"6bc1909b0c11","title":"package pers.chenjiahao.algorithm.selection;<br><br>/**<br> * 自己写的选择排序<br> */<br>public class MyselfSelectionSort {<br>    public static void main(String[] args) {<br>        // 创建一个排序的数组<br>        int[] arr = {8,5,5,2,64,38,65,4};<br>        arr = selectionSort(arr);<br>        // 打印最终排序的结果<br>        print(arr);<br>    }<br><br>    private static int[] selectionSort(int[] arr) {<br>        // arr.length - 1中 -1是因为最后一次就是本身不用比较了 ，小小的优化<br>        for (int i = 0; i &lt; arr.length - 1; i++) {<br>            // 定义一个变量存放最小值的下标，并将参与排序的第一个数的下标设为最小值的下标<br>            int minIndex = i;<br>            for (int j = i + 1; j &lt; arr.length; j++) {<br>                // 后面的数字比min还小就进行交换<br>                if (arr[minIndex] &gt; arr[j]){<br>                    // 修改最小值对应的下标<br>                    minIndex = j;<br>                }<br>            }<br>            // 判断一下有没有必要进行交换<br>            if (i != minIndex){<br>                // 进行开始位置和最小数位置的交换<br>                swap(arr,i,minIndex);<br>            }<br>            // 打印每一次排序的结果<br>            System.out.print(\"经过第\" + i + \"次排序之后，数组的内容\" + \":\");<br>            print(arr);<br>        }<br>        return arr;<br>    }<br><br>    private static void print(int[] arr){<br>        for (int k : arr) {<br>            System.out.print(k + \" \");<br>        }<br>        System.out.println();<br>    }<br><br>    private static void swap(int[] arr,int i,int minIndex){<br>        int temp = arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    }<br>}<br>"}],"id":"ebde1ffbb6dc","title":"代码"},{"parent":"b81d1c0ad642","children":[{"parent":"3d196589b83c","children":[],"id":"476b3968b73f","title":"package pers.chenjiahao.algorithm.selection.optimization;<br><br>/**<br> * 对选择排序进行优化<br> * 每次找到最小值和最大值<br> * 最小值放前面，最大值放后面<br> */<br>public class SelectionOptimization {<br>    public static void main(String[] args) {<br>        int[] arr = {5,3,6,10,8,1,7,9,4,2};<br>        selectionOptimization(arr);<br>    }<br><br>    public static void selectionOptimization(int[] arr) {<br>        for (int i = 0; i &lt; arr.length / 2; i++) {<br>            int minIndex = i;<br>            int maxIndex = arr.length - i - 1;<br>            for (int j = i + 1; j &lt; arr.length - i; j++) {<br>                if (arr[minIndex] &gt; arr[j]){<br>                    minIndex = j;<br>                    continue;<br>                }<br>                if (arr[maxIndex] &lt; arr[j]){<br>                    maxIndex = j;<br>                }<br>            }<br>            // 交换最小值<br>            int temp = arr[minIndex];<br>            arr[minIndex] = arr[i];<br>            arr[i] = temp;<br><br>            // 交换最大值<br>            temp = arr[maxIndex];<br>            arr[maxIndex] = arr[arr.length - i - 1];<br>            arr[arr.length - i - 1] = temp;<br><br>            System.out.println(\"第\" + (i + 1) + \"次排序\");<br>            System.out.println(\"更换的最小值坐标为:\" + minIndex);<br>            System.out.println(\"更换的最大值坐标为:\" + maxIndex);<br>            print(arr);<br>            System.out.println();<br>        }<br>    }<br><br>    private static void print(int[] arr){<br>        for (int i : arr) {<br>            System.out.print(i + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"3d196589b83c","title":"代码优化(每次找到最小值和最大值，对头和尾都进行交换)"}],"collapsed":true,"id":"b81d1c0ad642","title":"2.选择排序"},{"parent":"5acd06259d54","children":[{"parent":"ba2c8095d771","children":[],"id":"03956cb627c9","title":"整体思想：将数组中最大的数字像泡泡一样浮到最后一个位置上去，以此类推完成排序"},{"parent":"ba2c8095d771","children":[],"id":"2e5b863a0509","title":"每次都从第一个数字开始，两两比较，寻找最大的数字<br>如果前面的数字比后面的数字大，就交换位置，<br>如果前面的数字比后面的数字小，就不用交换位置，<br>继续下一组的比较。<br>比较原则：<br>&nbsp; &nbsp; &nbsp; &nbsp;0 1&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 2<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 3<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 4&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;......"},{"parent":"ba2c8095d771","image":{"w":406,"h":322,"url":"http://cdn.processon.com/5ff8046ee0b34d34e138a95f?e=1610093183&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:JBW5O2b4gpuA1rY3zE1JS1O7B48="},"children":[],"id":"0a8240780635","title":"例：对9 6 1 3 5 进行冒泡排序<br>"},{"parent":"ba2c8095d771","children":[{"parent":"b360d40b9895","children":[],"id":"5947cbbebf05","title":"package pers.chenjiahao.algorithm.bubble;<br><br>public class MySelfBubbleSort {<br>    public static void main(String[] args) {<br>        int[] arr = {5,3,6,8,10,1,7,9,4,2};<br>        // int[] arr = {9,1,2,3,4,5,6,7,8};<br>        bubbleSort(arr);<br>        print(arr);<br>    }<br><br>    private static void bubbleSort(int[] arr) {<br>        for (int i = 0; i &lt; arr.length - 1; i++) {<br>            findMax(arr,i);<br>        }<br>    }<br><br>    private static void findMax(int[] arr, int i) {<br>        for (int j = 0; j &lt; arr.length - 1 - i; j++) {<br>            if (arr[j] &gt; arr[j + 1]){<br>                swap(arr,j);<br>            }<br>        }<br>    }<br><br>    private static void swap(int[] arr, int j) {<br>        int temp = arr[j];<br>        arr[j] = arr[j + 1];<br>        arr[j+1] = temp;<br>    }<br><br>    private static void print(int[] arr){<br>        for (int i : arr) {<br>            System.out.println(i + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"b360d40b9895","title":"代码"},{"parent":"ba2c8095d771","children":[{"parent":"88170fbe8813","children":[],"id":"6a108cef8db1","title":"package pers.chenjiahao.algorithm.bubble.optimization;<br><br>public class BubbleSortOptimization {<br>    public static void main(String[] args) {<br>        int[] arr = {9,1,2,3,4,5,6,7,8};<br>        bubbleSort(arr);<br>        print(arr);<br>    }<br>    <br>    private static void bubbleSort(int[] arr){<br>        a:for (int i = arr.length - 1; i &gt; 0 ; i--){<br>            if (findMax(arr,i)){<br>                break a;<br>            }<br>        }<br>    }<br><br>    private static boolean findMax(int[] arr,int n){<br>        boolean flag = true;<br>        for (int j = 0; j &lt; n; j++) {<br>            if (arr[j] &gt; arr[j + 1]) {<br>                swap(arr,j);<br>                flag = false;<br>            }<br>        }<br>        return flag;<br>    }<br><br>    private static void swap(int[] arr,int j){<br>        int temp = arr[j];<br>        arr[j] = arr[j + 1];<br>        arr[j + 1] = temp;<br>    }<br><br>    private static void print(int[] arr){<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            System.out.println(arr[i] + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"88170fbe8813","title":"代码优化(如果一次交换都没发生的话，证明数组已经排序完成了，这样就是最好的情况O(n)了)"}],"collapsed":true,"id":"ba2c8095d771","title":"3.冒泡排序"},{"parent":"5acd06259d54","children":[{"parent":"68de15324f55","children":[],"id":"206285ead392","title":"主要思想是需要比出来小的，如果前面的比后面的大，就换位置"},{"parent":"68de15324f55","children":[],"id":"35a7159d2344","title":"从第二个位置上的数开始比较，每次都只会跟\"前面\"的数字进行比较，<br>如果比前面的数字小就进行交换，以此类推，直到找到合适的位置才结束这个数的排序<br>例如：<br>&nbsp; &nbsp; &nbsp; &nbsp;9 6 1 3 5<br>&nbsp; &nbsp; &nbsp; &nbsp;从第二个位置上的数字6开始向前比较，6比9小所以6和9交换位置，第一次排序结束，得到<br>&nbsp; &nbsp; &nbsp; &nbsp;6 9 1 3 5<br>&nbsp; &nbsp; &nbsp; &nbsp;从第三个位置上的数字1开始向前比较，1小于9所以1和9交换位置，得到<br>&nbsp; &nbsp; &nbsp; &nbsp;6 1 9 3 5<br>&nbsp; &nbsp; &nbsp; &nbsp;1再跟前面的6进行比较，1小于6所以1和6交换位置，第二次排序结束，得到<br>&nbsp; &nbsp; &nbsp; &nbsp;1 6 9 3 5<br>&nbsp; &nbsp; &nbsp; &nbsp; ......直到排完最后一个<br>"},{"image":{"w":420,"h":309,"url":"http://cdn.processon.com/5ff9478ff346fb55c5ffdca8?e=1610175903&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:4_SO4_jibThIFPKBAmCTaveepuw="},"parent":"68de15324f55","children":[],"id":"b4e0fcd96ff6","title":"对9 6 1 3 5进行排序"},{"parent":"68de15324f55","children":[{"parent":"9ada829eccd5","children":[],"id":"499666715166","title":"package pers.chenjiahao.algorithm.insertion;<br><br>public class MySelfInsertionSort {<br>    public static void main(String[] args) {<br>        int[] arr = {1,9,2,7,5,8,3,6,4};<br>        insertionSort(arr);<br>        print(arr);<br>    }<br><br>    static void insertionSort(int[] arr){<br>        // int i = 1;<br>        for (int i = 1; i &lt; arr.length; i++) {<br>            findMin(arr,i);<br>        }<br>    }<br><br>    static void findMin(int[] arr, int i) {<br>        for (int j = i; j &gt; 0; j--) {<br>            if (arr[j] &lt; arr[j - 1]){<br>                swap(arr,j);<br>            }<br>        }<br>    }<br><br>    static void swap(int[] arr,int j){<br>        int temp = arr[j];<br>        arr[j] = arr[j - 1];<br>        arr[j - 1] = temp;<br>    }<br><br>    static void print(int[] arr){<br>        for (int i : arr) {<br>            System.out.println(i + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"9ada829eccd5","title":"代码"},{"parent":"68de15324f55","children":[{"parent":"b82816f948fd","children":[],"id":"9e456ccf6143","title":"将当前开始排序的数字存入到一个临时变量中，<br>最后直接插入到需要插入的位置，提前将后面的所有数字都后移"},{"image":{"w":437,"h":118,"url":"http://cdn.processon.com/5ff94e0c1e0853437c6daecb?e=1610177564&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:JYLPwgCEg13tTJl3oHA_EZUU3eo="},"parent":"b82816f948fd","children":[],"id":"b9e4f536c4c5","title":""},{"parent":"b82816f948fd","children":[{"parent":"b33fd74eaa11","children":[],"id":"3d91f0bd37b5","title":"package pers.chenjiahao.algorithm.insertion.optimization;<br><br>public class InsertionSortUpdate {<br>    public static void main(String[] args) {<br>        int[] arr = {1,9,2,7,5,8,3,6,4};<br>        insertionSort(arr);<br>        print(arr);<br>    }<br><br>    static void insertionSort(int[] arr){<br>        // int i = 1;<br>        for (int i = 1; i &lt; arr.length; i++) {<br>            int temp = arr[i];<br>            findMin(arr,i,temp);<br>        }<br>    }<br><br>    static void findMin(int[] arr, int i,int temp) {<br>        for (int j = i; j &gt; 0; j--) {<br>            if (temp &lt; arr[j - 1]){<br>                arr[j] = arr[j - 1];<br>            }else {<br>                arr[j] = temp;<br>                break;<br>            }<br>        }<br>    }<br><br>    static void print(int[] arr){<br>        for (int i : arr) {<br>            System.out.print(i + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"b33fd74eaa11","title":"代码"}],"collapsed":true,"id":"b82816f948fd","title":"修改算法(用临时变量记录标记项，去掉swap方法)<br>"}],"collapsed":true,"id":"68de15324f55","title":"4.插入排序"},{"parent":"5acd06259d54","children":[{"parent":"f66ff31f9463","children":[],"id":"c5bd16e3b85b","title":"改进的插入排序，比插入排序的效率高一些<br>"},{"parent":"f66ff31f9463","children":[],"id":"a0d05d3dc3a9","title":"相对插入排序来说，多了一个间隔的概念，先确定一个间隔，每这个间隔的数字成一组，<br>每一组进行相对位置上的排序（例如：这一组的下标是1 4 7 10 ，这组数排完序之后，下标还是1 4 7 10），<br>然后向后推移，找下一组所有组都排完了之后，开始减小间隔，直至间隔为1排完一遍之后，完成了排序。<br>例如：<br>&nbsp; &nbsp; &nbsp; &nbsp; (9 6 3) (5 7 1) (4 2 8)<br>&nbsp; &nbsp; &nbsp; &nbsp; 以3为间隔分成三组<br>&nbsp; &nbsp; &nbsp; &nbsp; 9 5 4 、6 7 2 、3 1 8，三组分别排完序之后：<br>&nbsp; &nbsp; &nbsp; &nbsp; 4 5 9 、2 6 7 、1 3 8，重新组成的数组为<br>&nbsp; &nbsp; &nbsp; &nbsp; (4 2 1)( 5 6 3)( 9 7 8)，即以间隔为3的排序完成，下来可以进行间隔为2的排序，然后按照间隔为1排序（插入排序）<br>&nbsp; &nbsp; &nbsp; &nbsp; 排序完成&nbsp;<br>"},{"parent":"f66ff31f9463","children":[{"parent":"c9f0bd0f870f","image":{"w":557,"h":344,"url":"http://cdn.processon.com/5ff95de05653bb681fa2da88?e=1610181617&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ymsW_BjpGPIkS8u3hvKYYm74VKs="},"children":[],"id":"a8f11cbf0225","title":"间隔为4的排序，下图接"},{"parent":"c9f0bd0f870f","image":{"w":566,"h":323,"url":"http://cdn.processon.com/5ff95ed06376897ae0d5c79f?e=1610181856&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:OoBg0vmyfE4dUnqXMdYujbi5i6M="},"children":[],"id":"113f1f1b2fc4","title":"间隔为2和1的排序"}],"collapsed":true,"id":"c9f0bd0f870f","title":"图解"},{"parent":"f66ff31f9463","children":[],"id":"5aee24facbb7","title":"间隔大的时候移动的次数少<br>间隔小的时候移动的距离短"},{"parent":"f66ff31f9463","children":[{"parent":"3a85de76667b","children":[],"id":"a00ca5a0b24f","title":"1.最常见的，arr.length / 2"},{"parent":"3a85de76667b","children":[{"parent":"96aaadb65f01","children":[],"id":"22dbe80ce84b","title":"希尔排序中通常用gap或h表示间隔<br>h = 1<br>h = 3*h + 1<br>h = 1 , 4 , 13 , ........"},{"parent":"96aaadb65f01","children":[],"id":"a9e140ff1046","title":"寻找最大间隔采用<br>&nbsp; &nbsp; &nbsp;int h = 1;<br>&nbsp; &nbsp; &nbsp;while (h &lt;= arr.length / 3){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h = h * 3 + 1;<br>&nbsp; &nbsp; &nbsp;}<br>除以3的原因是，如果大于1/3的话，3*h+1就大于数组的长度了"}],"collapsed":true,"id":"96aaadb65f01","title":"2.Knuth序列，比/2效率高"}],"collapsed":true,"id":"3a85de76667b","title":"间隔的选择"},{"parent":"f66ff31f9463","children":[{"parent":"a0a7549ec08a","children":[],"id":"c750fb8706a2","title":"package pers.chenjiahao.algorithm.shell;<br><br>public class ShellSort {<br>    public static void main(String[] args) {<br>        int[] arr = {9,6,11,3,5,12,8,7,10,15,14,4,1,13,2};<br>        sort(arr);<br>        print(arr);<br>    }<br><br>    static void sort(int[] arr){<br>        int h = 1;<br>        while (h &lt;= arr.length / 3){<br>            h = h * 3 + 1;<br>        }<br>        for (int gap = h; gap &gt; 0; gap = (gap - 1) / 3) {<br>            for (int i = gap; i &lt; arr.length; i++) {<br>                for (int j = i; j &gt; gap - 1; j -= gap) {<br>                    if (arr[j] &lt; arr[j - gap]){<br>                        swap(arr,j,j - gap);<br>                    }<br>                }<br>            }<br>        }<br>    }<br><br>    static void swap(int[] arr,int i,int j){<br>        int temp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    }<br><br>    static void print(int[] arr){<br>        for (int i : arr) {<br>            System.out.print(i + \" \");<br>        }<br>    }<br><br>}<br>"}],"collapsed":true,"id":"a0a7549ec08a","title":"代码"}],"collapsed":true,"id":"f66ff31f9463","title":"5.希尔排序"},{"parent":"5acd06259d54","children":[{"parent":"733688c422d1","children":[],"id":"657d33c35fb4","title":"主要的思想就是递归"},{"parent":"733688c422d1","children":[],"id":"857cd73d6928","title":"如果数组没有排好顺序<br>首先对数组进行一分为二，如果想对这两半进行归并，必须要求子数组必须排好<br>如果想让子数组排好，必须对子数组分成两半进行归并，............. <br>直到不能分为止（子数组中有两个或者一个），然后开始从最小的子数组开始逐步归并<br>"},{"parent":"733688c422d1","children":[{"image":{"w":369,"h":156,"url":"http://cdn.processon.com/5ff98f12f346fb55c5011740?e=1610194210&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:rv2IXLDifqT4mUSyud34HAZrFOw="},"parent":"4a0aaf0c3014","children":[],"id":"618b2fc5e34d","title":"三个指针，新建一个新的数组，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;比较情况：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1和2，1比2小 将1放入到新数组中<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4和2，2比4小 将2放入到新数组中&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4和3，3比4小 将3放入到新数组中<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4和5，4比5小 将4放入到新数组中<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6和5，5比6小 将5放入到新数组中<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;................"},{"parent":"4a0aaf0c3014","children":[{"parent":"f5cb350923ed","children":[],"id":"41dd29cbcc0d","title":"package pers.chenjiahao.algorithm.merge;<br><br>public class MergeSort {<br>    public static void main(String[] args) {<br>        int[] arr = {1,4,7,8,3,6,9};<br>        sort(arr);<br>        // print(arr);<br>    }<br><br>    static void sort(int[] arr){<br>        merge(arr);<br>    }<br><br>    static void merge(int[] arr){<br>        int mid = arr.length &gt;&gt; 1;<br>        int[] temp = new int[arr.length];<br>        int i = 0;<br>        int j = mid + 1;<br>        int k = 0;<br>        while (i &lt;= mid &amp;&amp; j &lt; arr.length){<br>            // temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];<br>            if (arr[i] &lt;= arr[j]){<br>                temp[k++] = arr[i++];<br>                // i++;<br>                // k++;<br>            }else {<br>                temp[k++] = arr[j++];<br>                // j++;<br>                // k++;<br>            }<br>        }<br><br>        while (i&lt;=mid){<br>            temp[k++] = arr[i++];<br>        }<br>        while (j&lt;arr.length){<br>            temp[k++] = arr[j++];<br>        }<br>        print(temp);<br>    }<br><br>    static void swap(int[] arr,int i,int j){<br>        int temp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    }<br><br>    static void print(int[] arr){<br>        for (int i : arr) {<br>            System.out.print(i + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"f5cb350923ed","title":"代码"}],"collapsed":true,"id":"4a0aaf0c3014","title":"第一种情况（前半截和后半截都是有顺序的）"},{"parent":"733688c422d1","children":[{"parent":"0873191e22a9","children":[],"id":"ffddec6412cc","title":"给merge方法添加三个参数左起点，右起点，右边界<br>目的是为了给子数组进行排序"},{"parent":"0873191e22a9","children":[],"id":"8ae7d2cba024","title":"例：对1,11,10,4,6,2,7,5,3,8,9进行归并"},{"parent":"0873191e22a9","children":[{"parent":"5cbf32786e09","image":{"w":900,"h":731.7073170731708,"url":"http://cdn.processon.com/5ffc13701e0853437c3bb789?e=1610359168&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:qWWWl-ia4oCsqxkK-3rC4S6yiLg="},"children":[],"id":"e8fcf94c4b06","title":""}],"collapsed":true,"id":"5cbf32786e09","title":"图解"},{"parent":"0873191e22a9","children":[],"id":"be682b0e36ee","title":"图解中仅对第一次分组后的前一半进行的画图解释"},{"parent":"0873191e22a9","children":[{"parent":"cf560f24b05f","children":[],"id":"6ecc57d724ff","title":"package pers.chenjiahao.algorithm.merge.update;<br>/**<br> * 前半截和后半截不一定是有顺序的，要使用到递归<br> */<br>public class MySelfMergeSortUpdate {<br>    public static void main(String[] args) {<br>        int[] arr = {1,4,6,7,10,11,2,3,5,8,9};<br>        // int[] arr = {1,4,7,8,3,6,9};<br>        // int[] arr = {1,11,10,4,6,2,7,5,3,8,9};<br>        sort(arr,0,arr.length - 1);<br>        print(arr);<br>    }<br><br>    static void sort(int[] arr,int left,int right){<br>        if (left == right) return;<br>        // int mid = left + (right - left) / 2;<br>        int mid = (right + left) / 2;<br>        // 给左边排序<br>        sort(arr,left,mid);<br>        // 给右边排序<br>        sort(arr,mid + 1,right);<br>        // 左右两边归并<br>        merge(arr,left,mid + 1,right);<br>    }<br><br>    static void merge(int[] arr,int leftStart,int rightStart,int rightBound) {<br>        int mid = rightStart - 1;<br>        int[] temp = new int[rightBound - leftStart + 1];<br>        int i = leftStart;<br>        int j = rightStart;<br>        int k = 0;<br>        while (i &lt;= mid &amp;&amp; j &lt;= rightBound){<br>            if (arr[i] &lt;= arr[j]){<br>                temp[k++] = arr[i++];<br>            }else {<br>                temp[k++] = arr[j++];<br>            }<br>        }<br><br>        while (i &lt;= mid) temp[k++] = arr[i++];<br><br>        while (j &lt;= rightBound) temp[k++] = arr[j++];<br><br>        for (int l = 0; l &lt; temp.length; l++) {<br>            arr[leftStart + l] = temp[l];<br>        }<br>    }<br><br>    static void print(int[] arr){<br>        for (int i : arr) {<br>            System.out.print(i + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"cf560f24b05f","title":"代码"}],"collapsed":true,"id":"0873191e22a9","title":"第二种情况（使用到递归）"},{"parent":"733688c422d1","children":[],"id":"7087ab73eea2","title":"TimSort(改进的归并排序)"}],"collapsed":true,"id":"733688c422d1","title":"6.归并排序"},{"parent":"5acd06259d54","children":[{"parent":"d86487f164e0","children":[],"id":"135093e72c93","title":"在数组中先随便找一个数字，作为轴，比轴矮的排到前面，比轴高的排到后面，<br>此时，数组就被分成了两部分，在前半部分和后半部分，分别再找轴，再排。<br>重复以上的操作，直到分割完之后剩下一个元素的时候，开始返回(递归的结束条件)。<br>"},{"parent":"d86487f164e0","children":[],"id":"ad0fd1ccbf4d","title":"核心思想：依照每个轴排完之后，轴的位置就是这数字的位置，不用变了，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;再找下一个轴，以此类推"},{"parent":"d86487f164e0","children":[{"image":{"w":357,"h":170,"url":"http://cdn.processon.com/5ffc242df346fb55c5b826d5?e=1610363453&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:BxUtjOnvX4Nv-31E1dtr_B2nn9Y="},"parent":"e53e6c72ebc7","children":[],"id":"f2e488a1336f","title":"部分图解"}],"collapsed":true,"id":"e53e6c72ebc7","title":"例如：对1，4，6，9，10，2，3，5，8，7排序"},{"parent":"d86487f164e0","children":[{"parent":"7a481ecce478","children":[{"parent":"300a0fe36e55","children":[],"id":"a6272dd901e4","title":"选定每个数组中最后的数字作为轴，<br>数组从前往后开始遍历，<br>如果比轴小，就不动，<br>如果大于轴承，就和轴前面的数字进行交换，<br>&nbsp; &nbsp; &nbsp; &nbsp;用换回来的数字再跟轴比，如果比轴小，就不动，<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果大于轴，继续跟轴前面没有交换过的数字进行交换<br>以此类推"}],"collapsed":true,"id":"300a0fe36e55","title":"描述"},{"parent":"7a481ecce478","children":[{"parent":"d3da7d24d936","children":[],"id":"e7ebdd5939f9","title":"定义一个索引值 == arr.length - 2，这个值代表的是倒数第二个数字的下标，<br>如果“排序的索引值”+ 1 == 这个索引值时，将最后位置的数和这个索引值上的数进行交换，<br>即这次的排序完成"}],"collapsed":true,"id":"d3da7d24d936","title":"结束条件"},{"parent":"7a481ecce478","children":[{"parent":"128191c5592d","children":[],"id":"99836ef2792c","title":""},{"parent":"128191c5592d","children":[{"image":{"w":900,"h":464.2935377875137,"url":"http://cdn.processon.com/5ffc2e886376897ae0af0ef4?e=1610366104&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:lANll-rE8maUeH9hv9GgTLU03GI="},"parent":"11e72cb78127","children":[],"id":"fb0221e4cc6d","title":""}],"collapsed":true,"id":"11e72cb78127","title":"一次比较的过程"},{"parent":"128191c5592d","children":[{"parent":"fb6d4e2cf530","image":{"w":900,"h":372.9817007534984,"url":"http://cdn.processon.com/60065366e0b34d45d160860a?e=1611030902&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:f5Ds6qc5xHuhTMDVtp0_rgOz6sQ="},"children":[],"id":"d1f07d11839c","title":""}],"collapsed":true,"id":"fb6d4e2cf530","title":"完整的数组分割过程(1,6,10,8,2,5,9,7)<br>"},{"parent":"128191c5592d","children":[{"parent":"463ca39d64df","children":[],"id":"851d23b9d556","title":"package pers.chenjiahao.algorithm.quick;<br><br>/**<br> * 选定每个数组种最后的数字作为轴，<br> * 数组从前往后开始遍历，<br> * 如果比轴小，就不动，<br> * 如果大于轴承，就和轴前面的数字进行交换，<br> *        用换回来的数字再跟轴比，如果比轴小，就不动，<br> *                            如果大于轴，继续跟轴前面没有交换过的数字进行交换<br> * 以此类推<br> */<br>public class SimpleQuickSort {<br>    public static void main(String[] args) {<br>        // int[] arr ={1,6,2,9,10,11,5,8,7};<br>        // int[] arr ={1,6,9,10,11,5,8,7};<br>        // int[] arr ={1,6,9,10,2,5,8,7};<br>        int[] arr ={1,6,10,8,2,5,9,7};<br>        sort(arr,0,arr.length - 1);<br>        print(arr);<br>    }<br><br>    static void sort(int[] arr,int start,int end){<br>        if (start == end + 1) return;<br>        // 排序<br>        int retAxis = quick(arr,start,end);<br>        if (retAxis == -1) return;<br>        sort(arr,start,retAxis - 1);<br>        sort(arr,retAxis + 1,end);<br>    }<br><br>    static int quick(int[] arr,int startIndex,int axisIndex) {<br>        if (startIndex == axisIndex) return -1;<br>        // 数组的轴<br>        int axis = arr[axisIndex];<br>        // 轴的前一个位置的索引<br>        int axisBeforeIndex = axisIndex - 1;<br>        while (startIndex != axisBeforeIndex){<br>            if (arr[startIndex] &gt; axis){<br>                swap(arr,startIndex,axisBeforeIndex);<br>                // axisBeforeIndex前移一位<br>                axisBeforeIndex--;<br>                // 重新校验这个数字<br>                startIndex--;<br>            }<br>            startIndex++;<br>        }<br>        // 交换轴和axisBeforeIndex位置的数<br>        axisBeforeIndex = arr[startIndex] &gt; axis ? axisBeforeIndex : axisBeforeIndex + 1;<br>        swap(arr,axisIndex,axisBeforeIndex);<br>        // 返回现在轴的位置<br>        return axisBeforeIndex;<br>    }<br><br>    /**<br>     * 将轴的位置交换到合适的位置<br>     * @param arr 传入的数组<br>     * @param axisIndex 轴的位置<br>     * @param axisBeforeIndex 轴在数组中合适的位置<br>     */<br>    private static void swap(int[] arr, int axisIndex, int axisBeforeIndex) {<br>        int temp = arr[axisIndex];<br>        arr[axisIndex] = arr[axisBeforeIndex];<br>        arr[axisBeforeIndex] = temp;<br>    }<br><br>    static void print(int[] arr){<br>        for (int i : arr) {<br>            System.out.print(i + \" \");<br>        }<br>        System.out.println();<br>    }<br>}"}],"collapsed":true,"id":"463ca39d64df","title":"代码"}],"collapsed":true,"id":"128191c5592d","title":"例如：对1 6 9 10 2 5 8 7进行排序"}],"collapsed":true,"id":"7a481ecce478","title":"第一种(以每个数组的最后一个位置为轴)"},{"parent":"d86487f164e0","children":[{"parent":"844199f14395","children":[],"id":"75675b6e0834","title":"还是以数组的最后为轴，从左往右找第一个比轴大的数，<br>从右往左找第一个比轴小的数，让这两个数字直接做交换<br>"},{"parent":"844199f14395","children":[{"image":{"w":769,"h":251,"url":"http://cdn.processon.com/6006804de401fd261bcb9bd9?e=1611042398&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:yv_KJTZw9g3IKMZpJYtOFoEpVjs="},"parent":"a31c7e4cf7f2","children":[],"id":"b52b012ec5e8","title":"以7为轴的第一次交换"}],"collapsed":true,"id":"a31c7e4cf7f2","title":"一次的比较过程"},{"parent":"844199f14395","children":[{"image":{"w":900,"h":358.2975064488392,"url":"http://cdn.processon.com/60068a9d7d9c084cf9f0370f?e=1611045037&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ZoDWeyl_zsnbpP9af2Cxh5fG-v4="},"parent":"3b7f08d90256","children":[],"id":"69723be70aeb","title":""}],"collapsed":true,"id":"3b7f08d90256","title":"完整的过程图解"},{"parent":"844199f14395","children":[{"parent":"428cfd038fa0","children":[],"id":"83af03588420","title":"package pers.chenjiahao.algorithm.quick;<br><br>/**<br> * 两边同时找<br> *    还是以数组的最后为轴，<br> *    从左往右找第一个比轴大的数，<br> *    从右往左找第一个比轴小的数，<br> *    让这两个数字直接做交换<br> */<br>public class MySelfQuickSort {<br>    public static void main(String[] args) {<br>        int[] arr = {9,3,2,8,1,6,5,4,7};<br>        sort(arr,0,arr.length - 1);<br>        print(arr);<br>    }<br><br>    static void sort(int[] arr,int start,int end){<br>        if (start == end + 1) return;<br>        int retAxisIndex = quick(arr,start,end);<br>        if (retAxisIndex == -1){<br>            return;<br>        }<br>        sort(arr,start,retAxisIndex - 1);<br>        sort(arr,retAxisIndex + 1,end);<br>    }<br><br>    static int quick(int[] arr,int startIndex,int axisIndex) {<br>        if (startIndex == axisIndex){<br>            return -1;<br>        }<br>        // 轴<br>        int axis = arr[axisIndex];<br>        // 从左往右找的索引<br>        int leftStartIndex = startIndex;<br>        // 从右往左找的索引<br>        int rightStartIndex = axisIndex - 1;<br>        // 存储第一个比轴大的数,将第一个值赋给它<br>        int moreThanAxis;<br>        // 存储第一个比轴小的数<br>        int lessThanAxis;<br>        while (true){<br>            moreThanAxis = arr[leftStartIndex];<br>            lessThanAxis = arr[rightStartIndex];<br>            // 先从左往右找第一个比轴大的数<br>            for (int i = leftStartIndex; i &lt; axisIndex; i++) {<br>                if (arr[i] &gt; axis){<br>                    moreThanAxis = arr[i];<br>                    break;<br>                }<br>                leftStartIndex++;<br>            }<br>            if (moreThanAxis &lt; axis){<br>                // 比轴大的数没找到，直接完成排序<br>                return leftStartIndex;<br>            }<br>            // 从右往左找第一个比轴小的数<br>            for (int j = rightStartIndex; j &gt; leftStartIndex ; j--) {<br>                if (arr[j] &lt; axis){<br>                    lessThanAxis = arr[j];<br>                    break;<br>                }<br>                rightStartIndex--;<br>            }<br>            if (lessThanAxis &gt; axis){<br>                // 比轴大的数字找到了，比轴小的数字没找到，轴和比轴大的数字直接交换<br>                swap(arr,leftStartIndex,axisIndex);<br>                return leftStartIndex;<br>            }<br>            // 能走到这里说明，从左边找了一个大的，从右边找了一个小的，进行交换<br>            swap(arr,leftStartIndex,rightStartIndex);<br>            // print(arr);<br>        }<br>    }<br><br><br>    static void swap(int[] arr, int axisIndex, int axisBeforeIndex) {<br>        int temp = arr[axisIndex];<br>        arr[axisIndex] = arr[axisBeforeIndex];<br>        arr[axisBeforeIndex] = temp;<br>    }<br><br>    static void print(int[] arr){<br>        for (int i : arr) {<br>            System.out.print(i + \" \");<br>        }<br>        System.out.println();<br>    }<br>}<br>"}],"collapsed":true,"id":"428cfd038fa0","title":"代码"},{"parent":"844199f14395","children":[{"parent":"2e5efe8b0a4a","children":[],"id":"803c96719010","title":"package pers.chenjiahao.algorithm.quick;<br><br>public class QuickSort {<br>    public static void main(String[] args) {<br>        int[] arr = {7,3,2,6,8,1,9,5,4,10};<br>        sort(arr,0,arr.length - 1);<br>        print(arr);<br>    }<br><br>    private static void sort(int[] arr, int leftBound, int rightBound) {<br>        if (leftBound &gt;= rightBound) return;<br>        int retPivotIndex = partition(arr,leftBound,rightBound);<br>        sort(arr,leftBound,retPivotIndex - 1);<br>        sort(arr,retPivotIndex + 1,rightBound);<br>    }<br><br>    static int partition(int[] arr, int leftBound, int rightBound) {<br>        // 轴<br>        int pivot = arr[rightBound];<br>        int left = leftBound;<br>        int right = rightBound - 1;<br>        while (left &lt;= right){<br>            // 从左往右找第一个大于轴的位置<br>            while (left &lt;= right &amp;&amp; arr[left] &lt;= pivot) left++;<br>            // 从右往左找第一个小于轴的位置<br>            while (left &lt;= right &amp;&amp; arr[right] &gt; pivot) right--;<br>            if (left &lt; right) swap(arr,left,right);<br>        }<br>        swap(arr,left,rightBound);<br>        return left;<br>    }<br><br>    static void swap(int[] arr,int i,int j){<br>        int temp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    }<br><br>    static void print(int[] arr){<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            System.out.print(arr[i] + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"2e5efe8b0a4a","title":"精致代码"}],"collapsed":true,"id":"844199f14395","title":"第二种(两边同时找，找到之后直接做交换)<br>"},{"parent":"d86487f164e0","children":[{"parent":"f2bdd7577d0a","children":[],"id":"5c3e307d3f59","title":"思想，每次找两个轴，将数组分成三个区域，<br>******大前提：第一个轴比第二个小******<br>第一个区域存放小于第一个轴的数，<br>第二个区域存放大于第一个轴小于第二个轴的区域，<br>第三个区域存放大于第二个轴的数"},{"parent":"f2bdd7577d0a","children":[{"parent":"bece23e418ad","children":[],"id":"be224b8812cb","title":"算出数组长度的1/7（记做A）<br>找到数组的终点，减去A，找到第一个数<br>再减去A，找到第二个数<br>再减去A，找到第三个数<br>再减去A，找到第四个数<br>再减去A，找到第五个数<br>将这五个数排好顺序（从小到大）<br>*****如果这五个数有一个相等，就用单轴快排<br>*****如果这五个数都不相等，就选第二个和第四个数作为两个轴，使用双轴快排"},{"parent":"bece23e418ad","image":{"w":900,"h":453.8830297219559,"url":"http://cdn.processon.com/60084e8a5653bb1b2e302f12?e=1611160731&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:2QldWLzxrHS_5KMZcJ5cc9_-s4c="},"children":[],"id":"3218eeafd7f8","title":""}],"collapsed":true,"id":"bece23e418ad","title":"找轴"},{"parent":"f2bdd7577d0a","children":[{"image":{"w":900,"h":512.6126126126126,"url":"http://cdn.processon.com/6008605a0791294a0e9c4091?e=1611165290&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0P4cS5YkvINmBhO_skOGHv1g6jU="},"parent":"121856a10a59","children":[],"id":"d688f3fd72f1","title":""}],"collapsed":true,"id":"121856a10a59","title":"图解（这里选定数组的第一个和最后一个数为轴）"},{"parent":"f2bdd7577d0a","children":[{"parent":"92fb4b5686a7","children":[],"id":"110f39c8437f","title":"package pers.chenjiahao.algorithm.quick;<br><br>public class DualPivotQuickSort {<br>    public static void main(String[] args) {<br>        // int[] arr = {9,3,2,6,8,1,7};<br>        int[] arr = {6,3,2,7,4,5,9,8};<br>        sort(arr,0,arr.length - 1);<br>        print(arr);<br>    }<br><br>    static void sort(int[] arr,int start,int end){<br>        if(start &gt;= end) return;<br>        int[] retPivot = dualQuick(arr,start,end);<br>        if (retPivot[0] == -1) return;<br>        // 左递归：<br>        sort(arr,start,retPivot[0] - 1);<br>        // 中递归：<br>        sort(arr,retPivot[0] + 1,retPivot[1] - 1);<br>        // 右递归：<br>        sort(arr,retPivot[1] + 1,end);<br><br>    }<br><br>    private static int[] dualQuick(int[] arr, int start, int end) {<br>        int[] retPivot = {-1,-1};<br>        if (start == end) return retPivot;<br><br>        if (start + 1 == end){<br>            if (arr[start] &gt; arr[end]){<br>                swap(arr,start,end);<br>            }<br>            return retPivot;<br>        }<br>        // k是每次判断的数字<br>        int k = start + 1;<br>        // 左侧的点<br>        int left = start;<br>        // 右侧的点<br>        int right = end;<br>        // 最左侧的轴<br>        int leftPivot = arr[left];<br>        // 最右侧的轴<br>        int rightPivot = arr[right];<br>        // 要保证左侧的轴小于右侧的轴<br>        if (leftPivot &gt; rightPivot){<br>            swap(arr,left,right);<br>            leftPivot = arr[left];<br>            rightPivot = arr[right];<br>        }<br>        while (k &lt; right){<br>            // 小于第一个轴，不动,left++,k++<br>            if (arr[k] &lt; leftPivot){<br>                if (k - 1 != left){<br>                    swap(arr,k,left + 1);<br>                }<br>                left++;<br>                k++;<br>                continue;<br>            }<br>            // 大于第一个，小于第二个，不动<br>            if (arr[k] &gt; leftPivot &amp;&amp; arr[k] &lt; rightPivot){<br>                k++;<br>                continue;<br>            }<br>            // 能走到这里说明，这个数大于第一个轴和第二个轴，right--<br>            // 交换位置k上和right - 1上的数字<br>            right--;<br>            swap(arr,k,right);<br>        }<br>        // 交换左侧的轴和left指针<br>        swap(arr,start,left);<br>        // 交换右侧的轴和right指针<br>        swap(arr,end,right);<br>        // 将两个轴返回<br>        retPivot[0] = left;<br>        retPivot[1] = right;<br>        return retPivot;<br>    }<br><br>    static void swap(int[] arr,int i,int j){<br>        int temp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    }<br><br>    static void print(int[] arr){<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            System.out.print(arr[i] + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"92fb4b5686a7","title":"代码"}],"collapsed":true,"id":"f2bdd7577d0a","title":"第三种(Java内部使用的双轴快排)"}],"collapsed":true,"id":"d86487f164e0","title":"7.快速排序"},{"parent":"5acd06259d54","children":[{"parent":"e5b1deace058","children":[],"id":"55f1881d9fea","title":"计数排序是桶排序思想中特殊的一种情况"},{"parent":"e5b1deace058","children":[],"id":"f6e16ef08d7a","title":"非比较排序"},{"parent":"e5b1deace058","children":[],"id":"4324851ccbfa","title":"适用场景：量大但是范围小<br>&nbsp; &nbsp; &nbsp; &nbsp;例如：企业中万名员工年龄排序<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;快速得知高考名次"},{"parent":"e5b1deace058","children":[],"id":"4f0a5199c63c","title":"创建一个新的数组用来计数（全部初始化为0），<br>这个数组的长度就是上述场景中范围的长度，<br>数组中对应的索引就是在范围中对应的数字"},{"parent":"e5b1deace058","children":[],"id":"7e650d42cfd0","title":"开始遍历数据：依次取得范围中的数字，当作数组的索引，给对应数组下标上的数加1"},{"parent":"e5b1deace058","children":[],"id":"065c61982bee","title":"创建一个新的数组，和原来的数组一样长。将计数数组按照顺序存入"},{"parent":"e5b1deace058","children":[],"id":"8c9ab9c69047","title":"说白了就是记录了每个数出现了多少次"},{"parent":"e5b1deace058","children":[{"parent":"cf6a5f91cdb0","children":[],"id":"f2521a3a1c84","title":"职务分为三个级别：A、B、C"},{"parent":"cf6a5f91cdb0","children":[],"id":"2189489ef951","title":"张三&nbsp; &nbsp;A<br>李四&nbsp; &nbsp;B<br>王五&nbsp; &nbsp;C<br>赵六&nbsp; &nbsp;B<br>陈七&nbsp; &nbsp;A<br>"},{"parent":"cf6a5f91cdb0","children":[],"id":"20c75bea0ace","title":"创建计数数组：数组的长度为3(因为范围为A、B、C)<br>int[] arr = {0,0,0};"},{"parent":"cf6a5f91cdb0","children":[],"id":"b15527a45db1","title":"开始遍历数据<br>&nbsp; &nbsp; &nbsp; &nbsp;①先读取到A，A对应的是计数数组的0位置（也就是0位置上的数组加1）<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int[] arr = {1,0,0};<br>&nbsp; &nbsp; &nbsp; &nbsp;②再读取到B<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int[] arr = {1,1,0};<br>&nbsp; &nbsp; &nbsp; &nbsp;③读取到C<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int[] arr = {1,1,1};<br>&nbsp; &nbsp; &nbsp; &nbsp;④读取到B<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int[] arr = {1,2,1};<br>&nbsp; &nbsp; &nbsp; &nbsp;⑤读取到A<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int[] arr = {2,2,1};"},{"parent":"cf6a5f91cdb0","children":[],"id":"073526d24a83","title":"最终：计数数组就是           int[] arr = {2,2,1};"},{"parent":"cf6a5f91cdb0","children":[],"id":"d5b74f58df73","title":"创建新的数组，和原来的数组一样长<br>int[] newArr = new int[原员工数组的长度]"},{"parent":"cf6a5f91cdb0","children":[],"id":"0dad4c23391a","title":"将计数数组中的数据按照一定的顺序存入<br>newArr = {A,A,B,B,C};<br>解释：计数数组中第一个位置出现了两个A<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;第二个位置出现了两个B<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;第三个位置初夏了一个C"},{"parent":"cf6a5f91cdb0","children":[{"parent":"fb5a36398d1d","children":[],"id":"6656856ba128","title":"package pers.chenjiahao.algorithm.counting;<br><br>import java.util.Arrays;<br><br>/**<br> * 不稳定，<br> * 如果从100~150开始就浪费了(因为索引都是从0开始的)<br> */<br>public class CountSort {<br>    public static void main(String[] args) {<br>        int[] arr = {2,4,2,3,7,1,1,0,0,5,6,9,8,5,7,4,0,9};<br>        int[] result = sort(arr);<br>        System.out.println(Arrays.toString(result));<br>    }<br><br>    static int[] sort(int[] arr){<br>        int[] result = new int[arr.length];<br><br>        int[] count = new int[10];<br><br>        for (int i = 0; i &lt; arr.length; i++) {<br>            count[arr[i]]++;<br>        }<br><br>System.out.println(Arrays.toString(count));<br><br>for (int i = 0,j = 0; i &lt; count.length; i++) {<br>while (count[i]-- &gt; 0) result[j++] = i;<br>}<br><br>        return result;<br>    }<br>}<br>"}],"collapsed":true,"id":"fb5a36398d1d","title":"代码(存在问题，不稳定，而且如果从100~150开始就浪费了(因为索引都是从0开始的))<br>"},{"parent":"cf6a5f91cdb0","children":[{"parent":"0775cac72a6a","children":[],"id":"3281b0c51c81","title":"找出范围的最小值，数组中全部减去最小值，最后给新数组中每个数再加上最小值"},{"parent":"0775cac72a6a","children":[{"parent":"4a9c7073937b","children":[],"id":"c2ea9719f6ab","title":"package pers.chenjiahao.algorithm.counting;<br><br>/**<br> * 解决问题<br> * 如果从100~150开始就浪费了(因为索引都是从0开始的)<br> */<br>public class MySelfCountSortUpdate {<br>    public static void main(String[] args) {<br>        int[] arr = {105,105,104,101,101,100,100,103,100,102,100,104};<br>        int min = findMin(arr);<br>        sort(arr,min);<br>    }<br><br>    private static int findMin(int[] arr) {<br>        int min = arr[0];<br>        for (int i = 1; i &lt; arr.length; i++) {<br>            if (min &gt; arr[i]) min = arr[i];<br>        }<br>        return min;<br>    }<br><br>    static void sort(int[] arr,int min){<br>        countSort(arr,min);<br>    }<br><br>    private static void countSort(int[] arr,int min) {<br>        // 创建一个计数数组,因为数的范围是100~105 所以计数数组的长度为6<br>        int[] countArr = new int[6];<br><br>        // 将arr中的数字全部减去做小的数<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            arr[i] -= min;<br>        }<br>        // 开始遍历数据<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            countArr[arr[i]]++;<br>        }<br><br>        // 创建一个与原来数组等长的数组，用来存储计数后的结果<br>        int[] newArr = new int[arr.length];<br>        // 将计数数组存储到新数组中<br>        int k = 0;<br>        int j = 0;<br>        while (k &lt; newArr.length){<br>            for (int i = 0; i &lt; countArr[j]; i++) {<br>                newArr[k++] = j + min;<br>            }<br>            j++;<br>        }<br>        for (int i : newArr) {<br>            System.out.print(i + \" \");<br>        }<br>    }<br>}<br>"}],"collapsed":true,"id":"4a9c7073937b","title":"代码"}],"collapsed":true,"id":"0775cac72a6a","title":"解决浪费<br>"},{"parent":"cf6a5f91cdb0","children":[{"parent":"b895db83b63d","children":[],"id":"04e3bde70c2f","title":"采用累加数组"},{"parent":"b895db83b63d","children":[{"parent":"793ef39bc7fe","children":[],"id":"b1978147e641","title":"package pers.chenjiahao.algorithm.counting;<br><br>import java.util.Arrays;<br><br>/**<br> * 不稳定，<br> * 如果从100~150开始就浪费了(因为索引都是从0开始的)<br> */<br>public class CountSort {<br>    public static void main(String[] args) {<br>        int[] arr = {2,4,2,3,7,1,1,0,0,5,6,9,8,5,7,4,0,9};<br>        System.out.println(Arrays.toString(arr));<br>        int[] result = sort(arr);<br>        System.out.println(Arrays.toString(result));<br>    }<br><br>    static int[] sort(int[] arr){<br>        int[] result = new int[arr.length];<br><br>        int[] count = new int[10];<br><br>        for (int i = 0; i &lt; arr.length; i++) {<br>            count[arr[i]]++;<br>        }<br><br>        System.out.println(Arrays.toString(count));<br><br>//        for (int i = 0,j = 0; i &lt; count.length; i++) {<br>//            while (count[i]-- &gt; 0) result[j++] = i;<br>//        }<br><br>        // 对count数组进行累加<br>        for (int i = 1; i &lt; count.length; i++) {<br>            count[i] = count[i] + count[i - 1];<br>        }<br><br>        System.out.println(Arrays.toString(count));<br><br>        for (int i = arr.length - 1;i &gt;= 0; i--) {<br>            result[--count[arr[i]]] = arr[i];<br>        }<br>        return result;<br>    }<br>}<br>"}],"collapsed":true,"id":"793ef39bc7fe","title":"代码"}],"collapsed":false,"id":"b895db83b63d","title":"解决不稳定"}],"collapsed":true,"id":"cf6a5f91cdb0","title":"举例：公司中每个员工的职务（这个例子没啥意义，就是这种思想）"}],"collapsed":true,"id":"e5b1deace058","title":"8.计数排序"},{"parent":"5acd06259d54","children":[{"parent":"a18b51018622","children":[],"id":"dd6087dc5855","title":"筒思想的一种"},{"parent":"a18b51018622","children":[],"id":"c7ee7f0a4c60","title":"非比较排序"},{"parent":"a18b51018622","children":[],"id":"f5ccdef01726","title":"多关键字排序"},{"parent":"a18b51018622","children":[],"id":"ad5db54d5450","title":"排数字的时候，最大的数字有几位，就排几次"},{"parent":"a18b51018622","children":[{"parent":"09b70725620f","children":[],"id":"139a82f3ce46","title":"421 240 115 532 305 430 124<br>"},{"parent":"09b70725620f","children":[],"id":"3943a60410bb","title":"将每个数字的个、十、百位都可以当作是一种关键字"},{"parent":"09b70725620f","children":[],"id":"6a13110842f3","title":"第一次：以个位上的数进行排序<br>&nbsp; &nbsp;得到：240 430 421 532 124 115 305"},{"parent":"09b70725620f","children":[],"id":"35060379d33e","title":"第二次：在第一次排序完的基础上，以十位上的数排序<br>&nbsp; &nbsp; 得到：305 115 421 124 430 532 240<br>"},{"parent":"09b70725620f","children":[],"id":"92b9a2819c54","title":"第三次：在第二次排序完的基础上，以百位上的数排序<br>&nbsp; &nbsp; 得到：115 124 240 305 421 430 532"},{"parent":"09b70725620f","children":[],"id":"2c6c702a2efb","title":"如果再有千位万位，以此类推"},{"parent":"09b70725620f","children":[{"parent":"7d3822f23722","children":[],"id":"440045cd6e59","title":"package pers.chenjiahao.algorithm.radix;<br><br>import java.util.Arrays;<br><br>public class RadixSort {<br>    public static void main(String[] args) {<br>        int[] arr = {421,240,115,532,305,430,124};<br>        int maxDigits = findMaxDigits(arr);<br>        int[] retArr = radixSort(arr,maxDigits);<br>        System.out.println(\"最终结果：\" + Arrays.toString(retArr));<br>    }<br><br>    private static int[] radixSort(int[] arr,int maxDigits) {<br>        int[] result = new int[arr.length];<br>        int[] count = new int[10];<br><br>        for (int i = 0; i &lt; maxDigits; i++) {<br>            int division = (int) Math.pow(10,i);<br><br>            for (int j = 0; j &lt; arr.length; j++) {<br>                int num = arr[j] / division % 10;<br>                count[num]++;<br>            }<br><br>            System.out.println();<br>            System.out.println(Arrays.toString(count));<br><br>            for (int m = 1; m &lt; count.length; m++) {<br>                count[m] = count[m] + count[m - 1];<br>            }<br><br>            System.out.println(Arrays.toString(count));<br><br>            for (int n = arr.length - 1; n &gt;= 0; n--) {<br>                int num = arr[n] /division % 10;<br>                result[--count[num]] = arr[n];<br>            }<br><br>            // 将result中的值复制到arr中，<br>            System.arraycopy(result,0,arr,0,arr.length);<br>            // 初始化count数组全部为0<br>            Arrays.fill(count,0);<br>            System.out.println(\"第\"+ (i+1) +\"次的结果为:\" + Arrays.toString(result));<br>        }<br>        return result;<br>    }<br><br>    private static int findMaxDigits(int[] arr) {<br>        int max = arr[0];<br>        for (int i = 1; i &lt; arr.length; i++) {<br>            if (max &lt; arr[i]) max = arr[i];<br>        }<br>        return String.valueOf(max).length();<br>    }<br>}<br>"}],"collapsed":true,"id":"7d3822f23722","title":"代码实现"}],"collapsed":true,"id":"09b70725620f","title":"例如：对一组数进行排序"},{"parent":"a18b51018622","children":[],"id":"78db5bcf51ca","title":"实际中的例子：员工排序，先排年龄，再排工龄、再排身高体重.....<br>"}],"collapsed":true,"id":"a18b51018622","title":"9.基数排序"},{"parent":"5acd06259d54","children":[{"parent":"f8cc64186dc6","children":[],"id":"50cd191b02ac","title":"给小数排序"},{"image":{"w":900,"h":382.06770356816105,"url":"http://cdn.processon.com/6014ec771e08533484708f19?e=1611987591&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:VMAH0TZARliff1F94wmosggJW9c="},"parent":"f8cc64186dc6","children":[],"id":"fdb8d993a909","title":""},{"parent":"f8cc64186dc6","children":[],"id":"bcf17bd80c37","title":"也可以给小数同时乘以100，全部变成整数，先进行计算，最后再统一除以100输出"},{"parent":"f8cc64186dc6","children":[],"id":"e477cf3fa9c4","title":"先用桶排序，分好，再用归并排序将每个桶中进行排序"},{"parent":"f8cc64186dc6","children":[{"parent":"d4b04660d553","children":[],"id":"d437365eb7ac","title":"package pers.chenjiahao.algorithm.bucket;<br><br>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;<br><br>public class BucketSort {<br>    public static void main(String[] args) {<br>        // 对12个小数进行排序<br>        double[] arr = {0.0,0.12,0.18,0.93,0.45,0.76,0.89,0.03,0.55,0.98,0.67,1.0};<br>        bucketSort(arr);<br>    }<br><br>    private static void bucketSort(double[] arr) {<br>        double[] retArr = new double[arr.length];<br>        // 分为四个桶 [0.0,0.25)  [0.25,0.5)  [0.5,0.75)  [0.75,1.0]<br>        List&lt;Double&gt; bucketList1 = new ArrayList&lt;&gt;();<br>        List&lt;Double&gt; bucketList2 = new ArrayList&lt;&gt;();<br>        List&lt;Double&gt; bucketList3 = new ArrayList&lt;&gt;();<br>        List&lt;Double&gt; bucketList4 = new ArrayList&lt;&gt;();<br>        List[] bucketArr = {bucketList1,bucketList2,bucketList3,bucketList4};<br><br>        // 开始遍历源数组<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            if (0.0 &lt;= arr[i] &amp;&amp; arr[i] &lt; 0.25) bucketList1.add(arr[i]);<br>            if (0.25 &lt;= arr[i] &amp;&amp; arr[i] &lt; 0.5) bucketList2.add(arr[i]);<br>            if (0.5 &lt;= arr[i] &amp;&amp; arr[i] &lt; 0.75) bucketList3.add(arr[i]);<br>            if (0.75 &lt;= arr[i] &amp;&amp; arr[i] &lt;= 1.0) bucketList4.add(arr[i]);<br>        }<br><br>        // 开始对每个bucketList进行排序<br>        for (int i = 0; i &lt; bucketArr.length; i++) {<br>            sort(bucketArr[i]);<br>        }<br><br>        System.out.println(Arrays.toString(bucketArr));<br>    }<br><br>    private static void sort(List list) {<br>        for (int i = 1; i &lt; list.size(); i++) {<br>            for (int j = i; j &gt; 0 ; j--) {<br>                if ((double)list.get(j) &lt; (double)list.get(j - 1)){<br>                    double temp = (double) list.get(j);<br>                    list.set(j,list.get(j - 1));<br>                    list.set(j - 1,temp);<br>                }<br>            }<br>        }<br>    }<br>}<br>"}],"id":"d4b04660d553","title":"例：采用桶+插实现的例子"}],"collapsed":true,"id":"f8cc64186dc6","title":"10.桶排序"},{"parent":"5acd06259d54","children":[{"parent":"2fc2a1bb8b05","children":[],"id":"67394ff78bce","title":"基本思想<br>（1）将待排序序列构造成一个大顶堆<br>（2）此时，整个序列的最大值就是堆顶的根节点<br>（3）将其与末尾元素进行交换，此时末尾就为最大值<br>（4）然后将剩余n - 1个元素重新构造成一个堆，这样会得到n个元素的次小值。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如此反复执行，便能得到一个有序序列了<br>&nbsp;在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到了一个有序序列了"},{"parent":"2fc2a1bb8b05","children":[],"id":"9f15c95180c0","title":"具体实施方法：<br>1.将无需序列构建成一个堆，根据升序降序需求，选择大顶堆或者小顶堆<br>这里采用升序的思路<br>2.自左向右，自上而下，先找到最后一个非叶子结点。比较它的两个子结点，<br>&nbsp; &nbsp;再拿子结点中大的数组和这个非叶子结点进行比较，如果非叶子结点小，就换。<br>&nbsp; &nbsp;继续找下一个倒数的非叶子结点，以此类推，知道所有的非叶子结点都找完<br>3.将堆顶元素与末尾元素交换，将最大元素(堆顶的元素)与末尾元素进行交换。<br>&nbsp; &nbsp;这个数不再参与下一次的运算（排出了一个数）<br>3.以此类推，反复执行，直到没有非叶子结点，递归结束<br>"},{"parent":"2fc2a1bb8b05","children":[{"parent":"c46c7e1e86b5","children":[{"image":{"w":579,"h":493,"url":"http://cdn.processon.com/60150a5e7d9c0859efc2f717?e=1611995247&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:H756gbgiNr4UjbzPJMXFF2akRN4="},"parent":"608da4516a0b","children":[],"id":"55a4ba64c1b6","title":""}],"collapsed":true,"id":"608da4516a0b","title":"初始化数组"},{"parent":"c46c7e1e86b5","children":[{"image":{"w":494,"h":427,"url":"http://cdn.processon.com/60150a937d9c0859efc2f771?e=1611995299&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:AUUq8xSZQq3BquyAfCkpNFhjFUI="},"parent":"7bc63f8e0772","children":[],"id":"c70509f17546","title":""}],"collapsed":true,"id":"7bc63f8e0772","title":"第一次排序完成后，9就不参与运算了。以此类推"},{"parent":"c46c7e1e86b5","children":[{"parent":"b778dea324ec","image":{"w":900,"h":353.7265415549598,"url":"http://cdn.processon.com/60151aacf346fb7423bec5b7?e=1611999420&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:S5CCRwn4locyYpBwFWpOp_nKKeo="},"children":[],"id":"0d07ff3603e9","title":"图解"}],"collapsed":true,"id":"b778dea324ec","title":"详细图解"},{"parent":"c46c7e1e86b5","children":[{"parent":"a768f4097053","children":[],"id":"33b5f5acb0c6","title":"package pers.chenjiahao.algorithm.heap;<br><br>import java.util.Arrays;<br><br>public class HeapSort {<br>    public static void main(String[] args) {<br>        // 将数组进行升序排序<br>        int[] arr = {4,6,8,5,9};<br>        heapSort(arr);<br>    }<br><br>    // 堆排序的方法<br>    static void heapSort(int[] arr){<br>        int temp = 0;<br>        System.out.println(\"堆排序\");<br><br>        // 分布完成<br>//        adjustHeap(arr,1,arr.length);<br>//        System.out.println(\"第一次\" + Arrays.toString(arr)); // 4 9 8 5 6<br>//<br>//        adjustHeap(arr,0,arr.length);<br>//        System.out.println(\"第二次\" + Arrays.toString(arr)); // 9 6 8 5 4<br>        // arr.length / 2 - 1 得到最后一个非叶子结点<br>        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) {<br>            adjustHeap(arr,i,arr.length);<br>            System.out.println(Arrays.toString(arr));<br>        }<br><br>        // 5个数最大调四次<br>        for (int j = arr.length - 1; j &gt; 0; j--) {<br>            // 交换大顶堆的堆顶和最后一个数<br>            temp = arr[j];<br>            arr[j] = arr[0];<br>            arr[0] = temp;<br>            adjustHeap(arr,0,j);<br>            System.out.println(Arrays.toString(arr)); // 9 6 8 5 4<br>        }<br>        System.out.println(\"last:\" + Arrays.toString(arr)); // 9 6 8 5 4<br>    }<br><br>    /**<br>     * 将一个数组（二叉树），调整成一个大顶堆<br>     * 功能：将i所对应的非叶子结点作为根的树，调整成大顶堆<br>     * 距离 int[] arr = {4,6,8,5,9}; -&gt; i = 1 -&gt; adjustHeap -&gt; 得到{4,9,8,5,6}<br>     * @param arr 待调整的数组<br>     * @param i 表示非叶子结点在数组中的索引<br>     * @param length 表示对多少个元素进行调整，length是在逐渐减少的<br>     */<br>    static void adjustHeap(int[] arr,int i,int length){<br>        // 先取出当前元素的值，保存在一个临时变量<br>        int temp = arr[i];<br>        // 开始调整<br>        // int k = i * 2 + 1 k是i结点的左子结点<br>        for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) {<br>            // 左子的值小于右子的值<br>            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k+1]){<br>                // k指向右子结点<br>                k++;<br>            }<br>            if (arr[k] &gt; temp){<br>                arr[i] = arr[k]; // 把较大的值给到当前的非叶子结点<br>                i = k; // !!! i指向k，继续循环比较<br>            }else {<br>                break;<br>            }<br>        }<br>        // 将原来非叶子结点上的值放在i位置，<br>        // 如果arr[k] &gt; temp  i就相当于是k了 下面那句话的意思就是arr[k] = temp;<br>        // 如果arr[k] &lt;= temp i还是i，自己覆盖自己，等于没有变化<br>        arr[i] = temp;<br>    }<br>}<br>"}],"collapsed":true,"id":"a768f4097053","title":"代码"}],"collapsed":true,"id":"c46c7e1e86b5","title":"例：对4 6 8 5 9进行排序<br>"}],"collapsed":true,"id":"2fc2a1bb8b05","title":"11.堆排序"},{"parent":"5acd06259d54","children":[{"parent":"02b5bddbf3af","children":[],"id":"078b6018028c","title":"冒泡：基本不用，太慢"},{"parent":"02b5bddbf3af","children":[],"id":"244f338804d5","title":"选择：基本不用，不稳"},{"parent":"02b5bddbf3af","children":[],"id":"5fd97c7350e9","title":"插入：样本小且基本有序的时候效率比较高"}],"collapsed":true,"id":"02b5bddbf3af","title":"算法总结"}],"collapsed":true,"id":"5acd06259d54","title":"常见算法汇总"}],"id":"de0d58c51179","title":"算法"}],"root":true,"theme":"theme3","id":"root","title":"数据结构&amp;&amp;算法<br>","structure":"mind_right"}},"meta":{"exportTime":"2021-12-17 09:22:50","member":"6062a761e0b34d392e5b9889","diagramInfo":{"creator":"6062a761e0b34d392e5b9889","created":"2021-03-30 12:22:39","modified":"2021-12-17 08:35:35","title":"数据结构&算法","category":"mind_free"},"id":"6062a78fe0b34d392e5b98e1","type":"ProcessOn Schema File","version":"1.0"}}